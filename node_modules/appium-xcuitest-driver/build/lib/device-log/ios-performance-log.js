"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IOSPerformanceLog = void 0;
const lodash_1 = __importDefault(require("lodash"));
const helpers_1 = require("./helpers");
const line_consuming_log_1 = require("./line-consuming-log");
class IOSPerformanceLog extends line_consuming_log_1.LineConsumingLog {
    constructor(opts) {
        super({
            maxBufferSize: opts.maxEvents ?? helpers_1.MAX_BUFFERED_EVENTS_COUNT,
            log: opts.log,
        });
        this.remoteDebugger = opts.remoteDebugger;
        this._started = false;
    }
    async startCapture() {
        this.log.debug('Starting performance (Timeline) log capture');
        this._clearEntries();
        await this.remoteDebugger.startTimeline(this.onTimelineEvent.bind(this));
        this._started = true;
    }
    async stopCapture() {
        this.log.debug('Stopping performance (Timeline) log capture');
        await this.remoteDebugger.stopTimeline();
        this._started = false;
    }
    get isCapturing() {
        return this._started;
    }
    onTimelineEvent(event) {
        const serializedEntry = JSON.stringify(event);
        this.broadcast(serializedEntry);
        this.log.debug(`Received Timeline event: ${lodash_1.default.truncate(serializedEntry, { length: helpers_1.MAX_JSON_LOG_LENGTH })}`);
    }
}
exports.IOSPerformanceLog = IOSPerformanceLog;
exports.default = IOSPerformanceLog;
//# sourceMappingURL=ios-performance-log.js.map