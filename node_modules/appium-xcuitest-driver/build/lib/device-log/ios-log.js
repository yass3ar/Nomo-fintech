"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IOSLog = void 0;
const events_1 = require("events");
const lru_cache_1 = require("lru-cache");
const support_1 = require("appium/support");
// We keep only the most recent log entries to avoid out of memory error
const MAX_LOG_ENTRIES_COUNT = 10000;
class IOSLog extends events_1.EventEmitter {
    constructor(opts = {}) {
        super();
        this.maxBufferSize = opts.maxBufferSize ?? MAX_LOG_ENTRIES_COUNT;
        this.logs = new lru_cache_1.LRUCache({
            max: this.maxBufferSize,
        });
        this._log = opts.log ?? support_1.logger.getLogger(this.constructor.name);
    }
    get log() {
        return this._log;
    }
    // eslint-disable-next-line require-await
    async getLogs() {
        const result = [];
        for (const value of this.logs.rvalues()) {
            result.push(this._deserializeEntry(value));
        }
        this._clearEntries();
        return result;
    }
    _clearEntries() {
        this.logs.clear();
    }
    broadcast(entry) {
        let recentIndex = -1;
        for (const key of this.logs.keys()) {
            recentIndex = key;
            break;
        }
        const serializedEntry = this._serializeEntry(entry);
        this.logs.set(++recentIndex, serializedEntry);
        if (this.listenerCount('output')) {
            this.emit('output', this._deserializeEntry(serializedEntry));
        }
    }
}
exports.IOSLog = IOSLog;
exports.default = IOSLog;
//# sourceMappingURL=ios-log.js.map