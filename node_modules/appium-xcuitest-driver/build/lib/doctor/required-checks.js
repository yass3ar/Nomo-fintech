"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.homeEnvVarCheck = exports.xcodeToolsCheck = exports.XcodeToolsCheck = exports.xcodeCheck = exports.XcodeCheck = void 0;
/* eslint-disable require-await */
const support_1 = require("appium/support");
const teen_process_1 = require("teen_process");
const appium_xcode_1 = require("appium-xcode");
require("@colors/colors");
/** @satisfies {import('@appium/types').IDoctorCheck} */
class XcodeCheck {
    async diagnose() {
        try {
            const xcodePath = await (0, appium_xcode_1.getPath)();
            return support_1.doctor.ok(`xCode is installed at '${xcodePath}'`);
        }
        catch (err) {
            return support_1.doctor.nok(err.message);
        }
    }
    async fix() {
        return `Manually install ${'Xcode'.bold} and configure the active developer directory path using the xcode-select tool`;
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return false;
    }
}
exports.XcodeCheck = XcodeCheck;
exports.xcodeCheck = new XcodeCheck();
/** @satisfies {import('@appium/types').IDoctorCheck} */
class XcodeToolsCheck {
    async diagnose() {
        try {
            // https://github.com/appium/appium/issues/12093#issuecomment-459358120
            await (0, teen_process_1.exec)('xcrun', ['simctl', 'help']);
        }
        catch (err) {
            return support_1.doctor.nok(`Cannot run 'xcrun simctl': ${err.stderr || err.message}`);
        }
        try {
            await (0, teen_process_1.exec)('xcodebuild', ['-version']);
        }
        catch (err) {
            return support_1.doctor.nok(`Cannot run 'xcodebuild': ${err.stderr || err.message}`);
        }
        return support_1.doctor.ok(`xCode tools are installed and work properly`);
    }
    async fix() {
        return `Fix the problems xCode tools are compliaining about`;
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return false;
    }
}
exports.XcodeToolsCheck = XcodeToolsCheck;
exports.xcodeToolsCheck = new XcodeToolsCheck();
/**
 * @typedef EnvVarCheckOptions
 * @property {boolean} [expectDir] If set to true then
 * the path is expected to be a valid folder
 * @property {boolean} [expectFile] If set to true then
 * the path is expected to be a valid file
 */
/** @satisfies {import('@appium/types').IDoctorCheck} */
class EnvVarAndPathCheck {
    /**
     * @param {string} varName
     * @param {EnvVarCheckOptions} [opts={}]
     */
    constructor(varName, opts = {}) {
        this.ENVIRONMENT_VARS_TUTORIAL_URL = 'https://github.com/appium/java-client/blob/master/docs/environment.md';
        this.varName = varName;
        this.opts = opts;
    }
    async diagnose() {
        const varValue = process.env[this.varName];
        if (!varValue) {
            return support_1.doctor.nok(`${this.varName} environment variable is NOT set!`);
        }
        if (!await support_1.fs.exists(varValue)) {
            let errMsg = `${this.varName} is set to '${varValue}' but this path does not exist!`;
            return support_1.doctor.nok(errMsg);
        }
        const stat = await support_1.fs.stat(varValue);
        if (this.opts.expectDir && !stat.isDirectory()) {
            return support_1.doctor.nok(`${this.varName} is expected to be a valid folder, got a file path instead`);
        }
        if (this.opts.expectFile && stat.isDirectory()) {
            return support_1.doctor.nok(`${this.varName} is expected to be a valid file, got a folder path instead`);
        }
        return support_1.doctor.ok(`${this.varName} is set to: ${varValue}`);
    }
    async fix() {
        return (`Make sure the environment variable ${this.varName.bold} is properly configured for the Appium process. ` +
            `Refer ${this.ENVIRONMENT_VARS_TUTORIAL_URL} for more details.`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return false;
    }
}
exports.homeEnvVarCheck = new EnvVarAndPathCheck('HOME', { expectDir: true });
//# sourceMappingURL=required-checks.js.map