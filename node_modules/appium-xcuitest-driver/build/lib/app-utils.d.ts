/**
 * Verify whether the given application is compatible to the
 * platform where it is going to be installed and tested.
 *
 * @this {XCUITestDriver}
 * @returns {Promise<void>}
 * @throws {Error} If bundle architecture does not match the expected device architecture.
 */
export function verifyApplicationPlatform(this: import("./driver").XCUITestDriver): Promise<void>;
/**
 * @typedef {Object} LocalizableStringsOptions
 * @property {string} [app]
 * @property {string} [language='en']
 * @property {string} [localizableStringsDir]
 * @property {string} [stringFile]
 * @property {boolean} [strictMode]
 */
/**
 * Extracts string resources from an app
 *
 * @this {XCUITestDriver}
 * @param {LocalizableStringsOptions} opts
 * @returns {Promise<import('@appium/types').StringRecord>}
 */
export function parseLocalizableStrings(this: import("./driver").XCUITestDriver, opts?: LocalizableStringsOptions): Promise<import("@appium/types").StringRecord>;
/**
 * @typedef {Object} UnzipInfo
 * @property {string} rootDir
 * @property {number} archiveSize
 */
/**
 * Unzips a ZIP archive on the local file system.
 *
 * @param {string} archivePath Full path to a .zip archive
 * @returns {Promise<UnzipInfo>} temporary folder root where the archive has been extracted
 */
export function unzipFile(archivePath: string): Promise<UnzipInfo>;
/**
 * Unzips a ZIP archive from a stream.
 * Uses bdstar tool for this purpose.
 * This allows to optimize the time needed to prepare the app under test
 * to MAX(download, unzip) instead of SUM(download, unzip)
 *
 * @param {import('node:stream').Readable} zipStream
 * @returns {Promise<UnzipInfo>}
 */
export function unzipStream(zipStream: import("node:stream").Readable): Promise<UnzipInfo>;
/**
 * Builds Safari preferences object based on the given session capabilities
 *
 * @param {import('./driver').XCUITestDriverOpts} opts
 * @return {Promise<import('@appium/types').StringRecord>}
 */
export function buildSafariPreferences(opts: import("./driver").XCUITestDriverOpts): Promise<import("@appium/types").StringRecord>;
/**
 * The callback invoked by configureApp helper
 * when it is necessary to download the remote application.
 * We assume the remote file could be anythingm, but only
 * .zip and .ipa formats are supported.
 * A .zip archive can contain one or more
 *
 * @this {XCUITestDriver}
 * @param {import('@appium/types').DownloadAppOptions} opts
 * @returns {Promise<string>}
 */
export function onDownloadApp(this: import("./driver").XCUITestDriver, { stream, headers }: import("@appium/types").DownloadAppOptions): Promise<string>;
/**
 * @this {XCUITestDriver}
 * @param {import('@appium/types').PostProcessOptions} opts
 * @returns {Promise<import('@appium/types').PostProcessResult|false>}
 */
export function onPostConfigureApp(this: import("./driver").XCUITestDriver, { cachedAppInfo, isUrl, appPath }: import("@appium/types").PostProcessOptions): Promise<import("@appium/types").PostProcessResult | false>;
export const SAFARI_BUNDLE_ID: "com.apple.mobilesafari";
export const APP_EXT: ".app";
export const IPA_EXT: ".ipa";
export const SUPPORTED_EXTENSIONS: string[];
export type LocalizableStringsOptions = {
    app?: string | undefined;
    language?: string | undefined;
    localizableStringsDir?: string | undefined;
    stringFile?: string | undefined;
    strictMode?: boolean | undefined;
};
export type UnzipInfo = {
    rootDir: string;
    archiveSize: number;
};
export type XCUITestDriver = import("./driver").XCUITestDriver;
//# sourceMappingURL=app-utils.d.ts.map