"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pyidevice = void 0;
const teen_process_1 = require("teen_process");
const support_1 = require("appium/support");
const path_1 = __importDefault(require("path"));
const base_device_client_1 = require("./base-device-client");
// https://github.com/YueChen-C/py-ios-device
const BINARY_NAME = 'pyidevice';
const CRASH_REPORT_EXT = '.ips';
class Pyidevice extends base_device_client_1.BaseDeviceClient {
    constructor(opts) {
        super({ log: opts.log });
        this._udid = opts.udid;
        this._binaryPath = null;
    }
    async assertExists(isStrict = true) {
        if (this._binaryPath) {
            return true;
        }
        try {
            this._binaryPath = await support_1.fs.which(BINARY_NAME);
            return true;
        }
        catch (e) {
            if (isStrict) {
                throw new Error(`${BINARY_NAME} binary cannot be found in PATH. ` +
                    `Please make sure it is installed. Visit https://github.com/YueChen-C/py-ios-device for ` +
                    `more details.`);
            }
            return false;
        }
    }
    async listProfiles() {
        const { stdout } = await this.execute(['profiles', 'list']);
        return JSON.parse(stdout);
    }
    async installProfile(args) {
        const { profilePath, payload } = args;
        if (!profilePath && !payload) {
            throw new Error('Either the full path to the profile or its payload must be provided');
        }
        let tmpRoot;
        let srcPath = profilePath;
        try {
            if (!srcPath) {
                tmpRoot = await support_1.tempDir.openDir();
                srcPath = path_1.default.join(tmpRoot, 'cert.pem');
                if (Buffer.isBuffer(payload)) {
                    await support_1.fs.writeFile(srcPath, payload);
                }
                else {
                    await support_1.fs.writeFile(srcPath, payload, 'utf8');
                }
            }
            await this.execute(['profiles', 'install', '--path', srcPath], {
                logStdout: true,
            });
        }
        finally {
            if (tmpRoot) {
                await support_1.fs.rimraf(tmpRoot);
            }
        }
    }
    async removeProfile(name) {
        return (await this.execute(['profiles', 'remove', '--name', name], { logStdout: true })).stdout;
    }
    async listCrashes() {
        const { stdout } = await this.execute(['crash', 'list']);
        // Example output:
        // ['.', '..', 'SiriSearchFeedback-2023-12-06-144043.ips', '
        // SiriSearchFeedback-2024-05-22-194219.ips', 'JetsamEvent-2024-05-23-225056.ips',
        // 'JetsamEvent-2023-09-18-090920.ips', 'JetsamEvent-2024-05-16-054529.ips',
        // 'Assistant']
        return JSON.parse(stdout.replace(/'/g, '"'))
            .filter((x) => x.endsWith(CRASH_REPORT_EXT));
    }
    async exportCrash(name, dstFolder) {
        await this.execute(['crash', 'export', '--name', name], {
            logStdout: true,
            // The tool exports crash reports to the current working dir
            cwd: dstFolder,
        });
    }
    async collectPcap(dstFile) {
        return await this.execute(['pcapd', dstFile], {
            format: null,
            asynchronous: true,
        });
    }
    async execute(args, opts = {}) {
        await this.assertExists();
        const { cwd, format = 'json', logStdout = false, asynchronous = false } = opts;
        const finalArgs = [...args, '--udid', this._udid, '--network'];
        if (format) {
            finalArgs.push('--format', format);
        }
        const binaryPath = this._binaryPath;
        const cmdStr = support_1.util.quote([binaryPath, ...finalArgs]);
        this.log.debug(`Executing ${cmdStr}`);
        try {
            if (asynchronous) {
                const result = new teen_process_1.SubProcess(binaryPath, finalArgs, { cwd });
                await result.start(0);
                return result;
            }
            const result = await (0, teen_process_1.exec)(binaryPath, finalArgs, { cwd });
            if (logStdout) {
                this.log.debug(`Command output: ${result.stdout}`);
            }
            return result;
        }
        catch (e) {
            throw new Error(`'${cmdStr}' failed. Original error: ${e.stderr || e.stdout || e.message}`);
        }
    }
}
exports.Pyidevice = Pyidevice;
//# sourceMappingURL=py-ios-device-client.js.map