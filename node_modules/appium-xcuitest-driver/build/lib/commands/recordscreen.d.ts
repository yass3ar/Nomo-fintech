export class ScreenRecorder {
    constructor(udid: any, log: any, videoPath: any, opts?: {});
    videoPath: any;
    log: any;
    opts: {};
    udid: any;
    mainProcess: SubProcess | null;
    timeoutHandler: NodeJS.Timeout | null;
    start(timeoutMs: any): Promise<void>;
    interrupt(force?: boolean): Promise<boolean>;
    finish(): Promise<any>;
    cleanup(): Promise<void>;
}
declare namespace _default {
    let _recentScreenRecorder: ScreenRecorder | null;
    /**
     * Direct Appium to start recording the device screen
     *
     * Record the display of devices running iOS Simulator since Xcode 9 or real devices since iOS 11
     * (ffmpeg utility is required: 'brew install ffmpeg').
     * It records screen activity to a MPEG-4 file. Audio is not recorded with the video file.
     * If screen recording has been already started then the command will stop it forcefully and start a new one.
     * The previously recorded video file will be deleted.
     *
     * @param {import('./types').StartRecordingScreenOptions} [options] - The available options.
     * @returns {Promise<string>} Base64-encoded content of the recorded media file if
     *                   any screen recording is currently running or an empty string.
     * @throws {Error} If screen recording has failed to start.
     * @this {XCUITestDriver}
     */
    function startRecordingScreen(this: import("../driver").XCUITestDriver, options?: import("./types").StartRecordingScreenOptions | undefined): Promise<string>;
    /**
     * Direct Appium to stop screen recording and return the video
     *
     * If no screen recording process is running then the endpoint will try to get
     * the recently recorded file. If no previously recorded file is found and no
     * active screen recording processes are running then the method returns an
     * empty string.
     *
     * @param {import('./types').StopRecordingScreenOptions} options - The available
     * options.
     * @returns {Promise<string?>} Base64-encoded content of the recorded media
     * file if `remotePath` parameter is empty or null or an empty string.
     * @throws {Error} If there was an error while getting the name of a media
     *                 file or the file content cannot be uploaded to the remote
     *                 location.
     * @this {XCUITestDriver}
     */
    function stopRecordingScreen(this: import("../driver").XCUITestDriver, options?: import("./types").StopRecordingScreenOptions): Promise<string | null>;
}
export default _default;
export type XCUITestDriver = import("../driver").XCUITestDriver;
import { SubProcess } from 'teen_process';
//# sourceMappingURL=recordscreen.d.ts.map