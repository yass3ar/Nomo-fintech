/**
 * Asserts that the given driver is running on a Simulator.
 *
 * @param {string} action - Description of action
 * @param {import('./driver').XCUITestDriver} driver
 */
export function assertSimulator(action: string, driver: import("./driver").XCUITestDriver): void;
/**
 * Check if platform name is the TV OS one.
 *
 * @param {string|null|undefined} platformName
 * @returns {boolean}
 */
export function isTvOs(platformName: string | null | undefined): boolean;
/**
 * Return normalized platform name.
 *
 * @param {string|null|undefined} platformName
 * @returns {string}
 */
export function normalizePlatformName(platformName: string | null | undefined): string;
/**
 * @param {import('./driver').XCUITestDriverOpts} opts
 * @returns {boolean}
 */
export function shouldSetInitialSafariUrl(opts: import("./driver").XCUITestDriverOpts): boolean;
/**
 * @param {import('./driver').XCUITestDriverOpts} opts
 * @returns {boolean}
 */
export function isIos17OrNewer(opts: import("./driver").XCUITestDriverOpts): boolean;
export const UDID_AUTO: "auto";
export const NATIVE_WIN: "NATIVE_APP";
export type UploadOptions = {
    /**
     * - The name of the user for the remote authentication. Only works if `remotePath` is provided.
     */
    user?: string | undefined;
    /**
     * - The password for the remote authentication. Only works if `remotePath` is provided.
     */
    pass?: string | undefined;
    /**
     * - The http multipart upload method name. The 'PUT' one is used by default.
     * Only works if `remotePath` is provided.
     */
    method?: import("axios").Method | undefined;
    /**
     * - Additional headers mapping for multipart http(s) uploads
     */
    headers?: import("@appium/types").HTTPHeaders | undefined;
    /**
     * [file] - The name of the form field, where the file content BLOB should be stored for
     *          http(s) uploads
     */
    fileFieldName?: string | undefined;
    /**
     * - Additional form fields for multipart http(s) uploads
     */
    formFields?: [string, any][] | Record<string, any> | undefined;
};
export type DriverInfo = {
    /**
     * Driver version string
     */
    version: string;
    /**
     * Driver build timestamp
     */
    built: string;
};
export type XcodeVersion = import("appium-xcode").XcodeVersion;
/**
 * @privateRemarks Is the minimum version really Xcode 7.3?
 * @returns {Promise<XcodeVersion>}
 */
export function getAndCheckXcodeVersion(): Promise<XcodeVersion>;
/**
 * @returns {Promise<string|null>}
 */
export function getAndCheckIosSdkVersion(): Promise<string | null>;
export function checkAppPresent(app: any): Promise<void>;
/**
 * @typedef {Object} DriverInfo
 * @property {string} version Driver version string
 * @property {string} built Driver build timestamp
 */
/**
 * @returns {DriverInfo}
 */
export const getDriverInfo: (() => Promise<{
    built: string;
    version: any;
}>) & _.MemoizedFunction;
export function clearSystemFiles(wda: any): Promise<void>;
/**
 *
 * @param {string} platformVersion
 * @param {string} deviceName
 * @returns {string}
 */
export function translateDeviceName(platformVersion: string, deviceName: string): string;
export function normalizeCommandTimeouts(value: any): any;
export const DEFAULT_TIMEOUT_KEY: "default";
export function markSystemFilesForCleanup(wda: any): Promise<void>;
export function printUser(): Promise<void>;
/**
 * Get the IDs of processes listening on the particular system port.
 * It is also possible to apply additional filtering based on the
 * process command line.
 *
 * @param {string|number} port - The port number.
 * @param {?Function} filteringFunc - Optional lambda function, which
 *                                    receives command line string of the particular process
 *                                    listening on given port, and is expected to return
 *                                    either true or false to include/exclude the corresponding PID
 *                                    from the resulting array.
 * @returns {Promise<string[]>} - the list of matched process ids.
 */
export function getPIDsListeningOnPort(port: string | number, filteringFunc?: Function | null): Promise<string[]>;
/**
 * @typedef {Object} UploadOptions
 *
 * @property {string} [user] - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {string} [pass] - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {import('axios').Method} [method] - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 * @property {import('@appium/types').HTTPHeaders} [headers] - Additional headers mapping for multipart http(s) uploads
 * @property {string} [fileFieldName] [file] - The name of the form field, where the file content BLOB should be stored for
 *                                            http(s) uploads
 * @property {Record<string, any> | [string, any][]} [formFields] - Additional form fields for multipart http(s) uploads
 */
/**
 * Encodes the given local file to base64 and returns the resulting string
 * or uploads it to a remote server using http/https or ftp protocols
 * if `remotePath` is set
 *
 * @param {string} localPath - The path to an existing local file
 * @param {string|null} [remotePath] - The path to the remote location, where
 *                               this file should be uploaded
 * @param {UploadOptions} uploadOptions - Set of upload options
 * @returns {Promise<string>} Either an empty string if the upload was successful or
 * base64-encoded file representation if `remotePath` is falsy
 */
export function encodeBase64OrUpload(localPath: string, remotePath?: string | null | undefined, uploadOptions?: UploadOptions): Promise<string>;
/**
 * Stops and removes all web socket handlers that are listening
 * in scope of the currect session.
 *
 * @param {Object} server - The instance of NodeJs HTTP server,
 * which hosts Appium
 * @param {string|null} sessionId - The id of the current session
 */
export function removeAllSessionWebSocketHandlers(server: any, sessionId: string | null): Promise<void>;
/**
 * Returns true if the urlString is localhost
 * @param {string} urlString
 * @returns {boolean} Return true if the urlString is localhost
 */
export function isLocalHost(urlString: string): boolean;
/**
 * Normalizes platformVersion to a valid iOS version string
 *
 * @param {string} originalVersion - Loose version number, that can be parsed by semver
 * @return {string} iOS version number in <major>.<minor> format
 * @throws {Error} if the version number cannot be parsed
 */
export function normalizePlatformVersion(originalVersion: string): string;
/**
 * @param {string[]} locations
 * @returns {Promise<void>}
 */
export function clearLogs(locations: string[]): Promise<void>;
/**
 * Assert the presence of particular keys in the given object
 *
 * @param {string|Array<string>} argNames one or more key names
 * @param {Object} opts the object to check
 * @returns {Object} the same given object
 */
export function requireArgs(argNames: string | Array<string>, opts?: any): any;
import _ from 'lodash';
//# sourceMappingURL=utils.d.ts.map