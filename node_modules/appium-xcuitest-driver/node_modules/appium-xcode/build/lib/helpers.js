"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XCRUN_TIMEOUT = void 0;
exports.runXcrunCommand = runXcrunCommand;
exports.findAppPaths = findAppPaths;
exports.readXcodePlist = readXcodePlist;
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const teen_process_1 = require("teen_process");
const support_1 = require("@appium/support");
const path_1 = __importDefault(require("path"));
exports.XCRUN_TIMEOUT = 15000;
/**
 * Executes 'xcrun' command line utility
 *
 * @param {string[]} args xcrun arguments
 * @param {number} timeout [15000] The maximum number of milliseconds to wait until xcrun exists
 * @returns {Promise<import("teen_process").TeenProcessExecResult>} The result of xcrun execution
 * @throws {Error} If xcrun returned non-zero exit code or timed out
 */
async function runXcrunCommand(args, timeout = exports.XCRUN_TIMEOUT) {
    try {
        return await (0, teen_process_1.exec)('xcrun', args, { timeout });
    }
    catch (err) {
        // the true error can be hidden within the stderr
        if (err.stderr) {
            err.message = `${err.message}: ${err.stderr}`;
        }
        throw err;
    }
}
/**
 * Uses macOS Spotlight service to detect where the given app is installed
 *
 * @param {string} bundleId Bundle identifier of the target app
 * @returns {Promise<string[]>} Full paths to where the app with the given bundle id is present.
 */
async function findAppPaths(bundleId) {
    let stdout;
    try {
        ({ stdout } = await (0, teen_process_1.exec)('/usr/bin/mdfind', [
            `kMDItemCFBundleIdentifier=${bundleId}`
        ]));
    }
    catch (e) {
        return [];
    }
    const matchedPaths = lodash_1.default.trim(stdout)
        .split('\n')
        .map(lodash_1.default.trim)
        .filter(Boolean);
    if (lodash_1.default.isEmpty(matchedPaths)) {
        return [];
    }
    const results = matchedPaths.map((p) => (async () => {
        if (await support_1.fs.exists(p)) {
            return p;
        }
    })());
    return /** @type {string[]} */ (await bluebird_1.default.all(results)).filter(Boolean);
}
/**
 * Finds and retrieves the content of the Xcode's Info.plist file
 *
 * @param {string} developerRoot Full path to the Contents/Developer folder under Xcode.app root
 * @returns {Promise<object>} All plist entries as an object or an empty object if no plist was found
 */
async function readXcodePlist(developerRoot) {
    const plistPath = path_1.default.resolve(developerRoot, '..', 'Info.plist');
    return await support_1.fs.exists(plistPath)
        ? await support_1.plist.parsePlistFile(plistPath)
        : {};
}
//# sourceMappingURL=helpers.js.map