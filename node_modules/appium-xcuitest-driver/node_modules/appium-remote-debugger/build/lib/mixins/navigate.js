"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PAGE_READINESS_TIMEOUT_MS = void 0;
exports.frameDetached = frameDetached;
exports.cancelPageLoad = cancelPageLoad;
exports.isPageLoadingCompleted = isPageLoadingCompleted;
exports.waitForDom = waitForDom;
exports.checkPageIsReady = checkPageIsReady;
exports.navToUrl = navToUrl;
const utils_1 = require("../utils");
const events_1 = __importDefault(require("./events"));
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const base_driver_1 = require("@appium/base-driver");
const rpc_1 = require("../rpc");
const property_accessors_1 = require("./property-accessors");
exports.DEFAULT_PAGE_READINESS_TIMEOUT_MS = 20 * 1000;
const PAGE_READINESS_CHECK_INTERVAL_MS = 50;
const PAGE_READINESS_JS_MIN_CHECK_INTERVAL_MS = 1000;
const CONSOLE_ENABLEMENT_TIMEOUT_MS = 20 * 1000;
/**
 * pageLoadStrategy in WebDriver definitions.
 */
const PAGE_LOAD_STRATEGY = {
    EAGER: 'eager',
    NONE: 'none',
    NORMAL: 'normal'
};
/**
 * @this {RemoteDebugger}
 * @returns {void}
 */
function frameDetached() {
    this.emit(events_1.default.EVENT_FRAMES_DETACHED);
}
/**
 * @this {RemoteDebugger}
 * @returns {void}
 */
function cancelPageLoad() {
    this.log.debug('Unregistering from page readiness notifications');
    (0, property_accessors_1.setPageLoading)(this, false);
    (0, property_accessors_1.getPageLoadDelay)(this)?.cancel();
}
/**
 * Return if current readState can be handles as page load completes
 * for the given page load strategy.
 *
 * @this {RemoteDebugger}
 * @param {string} readyState
 * @returns {boolean}
 */
function isPageLoadingCompleted(readyState) {
    const _pageLoadStrategy = lodash_1.default.toLower((0, property_accessors_1.getPageLoadStartegy)(this));
    if (_pageLoadStrategy === PAGE_LOAD_STRATEGY.NONE) {
        return true;
    }
    if (_pageLoadStrategy === PAGE_LOAD_STRATEGY.EAGER) {
        // This could include 'interactive' or 'complete'
        return readyState !== 'loading';
    }
    // Default behavior. It includes pageLoadStrategy is 'normal' as well.
    return readyState === 'complete';
}
/**
 * @this {RemoteDebugger}
 * @param {timing.Timer?} [startPageLoadTimer]
 * @returns {Promise<void>}
 */
async function waitForDom(startPageLoadTimer) {
    this.log.debug('Waiting for page readiness');
    const readinessTimeoutMs = this.pageLoadMs;
    if (!lodash_1.default.isFunction(startPageLoadTimer?.getDuration)) {
        this.log.debug(`Page load timer not a timer. Creating new timer`);
        startPageLoadTimer = new support_1.timing.Timer().start();
    }
    let isPageLoading = true;
    (0, property_accessors_1.setPageLoading)(this, true);
    (0, property_accessors_1.setPageLoadDelay)(this, support_1.util.cancellableDelay(readinessTimeoutMs));
    /** @type {B<void>} */
    const pageReadinessPromise = bluebird_1.default.resolve((async () => {
        let retry = 0;
        while (isPageLoading) {
            // if we are ready, or we've spend too much time on this
            // @ts-ignore startPageLoadTimer is defined here
            const elapsedMs = startPageLoadTimer.getDuration().asMilliSeconds;
            // exponential retry
            const intervalMs = Math.min(PAGE_READINESS_CHECK_INTERVAL_MS * Math.pow(2, retry), readinessTimeoutMs - elapsedMs);
            await bluebird_1.default.delay(intervalMs);
            // we can get this called in the middle of trying to find a new app
            if (!(0, property_accessors_1.getAppIdKey)(this)) {
                this.log.debug('Not connected to an application. Ignoring page readiess check');
                return;
            }
            if (!isPageLoading) {
                return;
            }
            if (await this.checkPageIsReady()) {
                if (isPageLoading) {
                    this.log.debug(`Page is ready in ${elapsedMs}ms`);
                    isPageLoading = false;
                }
                return;
            }
            if (elapsedMs > readinessTimeoutMs) {
                this.log.info(`Timed out after ${readinessTimeoutMs}ms of waiting for the page readiness. Continuing anyway`);
                isPageLoading = false;
                return;
            }
            retry++;
        }
    })());
    /** @type {B<void>} */
    const cancellationPromise = bluebird_1.default.resolve((async () => {
        try {
            await (0, property_accessors_1.getPageLoadDelay)(this);
        }
        catch (ign) { }
    })());
    try {
        await bluebird_1.default.any([cancellationPromise, pageReadinessPromise]);
    }
    finally {
        isPageLoading = false;
        (0, property_accessors_1.setPageLoading)(this, false);
        (0, property_accessors_1.setPageLoadDelay)(this, bluebird_1.default.resolve());
    }
}
/**
 * @this {RemoteDebugger}
 * @param {number} [timeoutMs]
 * @returns {Promise<boolean>}
 */
async function checkPageIsReady(timeoutMs) {
    (0, utils_1.checkParams)({
        appIdKey: (0, property_accessors_1.getAppIdKey)(this),
    });
    const readyCmd = 'document.readyState;';
    const actualTimeoutMs = timeoutMs ?? (0, property_accessors_1.getPageReadyTimeout)(this);
    try {
        const readyState = await bluebird_1.default.resolve(this.execute(readyCmd, true))
            .timeout(actualTimeoutMs);
        this.log.debug(`Document readyState is '${readyState}'. ` +
            `The pageLoadStrategy is '${(0, property_accessors_1.getPageLoadStartegy)(this) ?? PAGE_LOAD_STRATEGY.NORMAL}'`);
        return this.isPageLoadingCompleted(readyState);
    }
    catch (err) {
        if (!(err instanceof bluebird_1.default.TimeoutError)) {
            throw err;
        }
        this.log.debug(`Page readiness check timed out after ${actualTimeoutMs}ms`);
        return false;
    }
}
/**
 * @this {RemoteDebugger}
 * @param {string} url
 * @returns {Promise<void>}
 */
async function navToUrl(url) {
    const appIdKey = (0, property_accessors_1.getAppIdKey)(this);
    const pageIdKey = (0, property_accessors_1.getPageIdKey)(this);
    (0, utils_1.checkParams)({ appIdKey, pageIdKey });
    const rpcClient = this.requireRpcClient();
    try {
        new URL(url);
    }
    catch (e) {
        throw new TypeError(`'${url}' is not a valid URL`);
    }
    (0, property_accessors_1.setNavigatingToPage)(this, true);
    this.log.debug(`Navigating to new URL: '${url}'`);
    const readinessTimeoutMs = this.pageLoadMs;
    /** @type {(() => void)|undefined} */
    let onPageLoaded;
    /** @type {(() => void)|undefined} */
    let onPageChanged;
    /** @type {(() => void)|undefined} */
    let onTargetProvisioned;
    /** @type {NodeJS.Timeout|undefined|null} */
    let onPageLoadedTimeout;
    (0, property_accessors_1.setPageLoadDelay)(this, support_1.util.cancellableDelay(readinessTimeoutMs));
    (0, property_accessors_1.setPageLoading)(this, true);
    let isPageLoading = true;
    let didPageFinishLoad = false;
    /** @type {Promise<void>|null} */
    let pageReadinessCheckPromise = null;
    const start = new support_1.timing.Timer().start();
    /** @type {B<void>} */
    const pageReadinessPromise = new bluebird_1.default((resolve) => {
        const performPageReadinessCheck = async () => {
            while (isPageLoading) {
                const pageReadyCheckStart = new support_1.timing.Timer().start();
                try {
                    const isReady = await this.checkPageIsReady(PAGE_READINESS_JS_MIN_CHECK_INTERVAL_MS);
                    if (isReady && isPageLoading && onPageLoaded) {
                        return onPageLoaded();
                    }
                }
                catch (ign) { }
                const msLeft = PAGE_READINESS_JS_MIN_CHECK_INTERVAL_MS - pageReadyCheckStart.getDuration().asMilliSeconds;
                if (msLeft > 0 && isPageLoading) {
                    await bluebird_1.default.delay(msLeft);
                }
            }
        };
        onPageLoadedTimeout = setTimeout(() => {
            if (isPageLoading) {
                isPageLoading = false;
                this.log.info(`Timed out after ${start.getDuration().asMilliSeconds.toFixed(0)}ms of waiting ` +
                    `for the ${url} page readiness. Continuing anyway`);
            }
            return resolve();
        }, readinessTimeoutMs);
        onPageLoaded = () => {
            if (isPageLoading) {
                isPageLoading = false;
                this.log.debug(`The page ${url} is ready in ${start.getDuration().asMilliSeconds.toFixed(0)}ms`);
            }
            if (onPageLoadedTimeout) {
                clearTimeout(onPageLoadedTimeout);
                onPageLoadedTimeout = null;
            }
            didPageFinishLoad = true;
            return resolve();
        };
        // Sometimes it could be observed that we do not receive
        // any events for target provisioning while navigating to a new page,
        // but only events related to the page change.
        // So lets just start the monitoring loop as soon as any of these events arrives
        // for the target page.
        onPageChanged = async (
        /** @type {Error|null} */ err, 
        /** @type {string} */ _appIdKey, 
        /** @type {import("@appium/types").StringRecord} */ pageDict) => {
            if (_appIdKey !== appIdKey) {
                return;
            }
            /** @type {import('../types').Page|undefined} */
            const targetPage = (0, utils_1.pageArrayFromDict)(pageDict)
                .find(({ id }) => parseInt(`${id}`, 10) === parseInt(`${pageIdKey}`, 10));
            if (targetPage?.url === url) {
                this.log.debug(`The page ${targetPage.id} has the expected URL ${url}`);
                if (pageReadinessCheckPromise) {
                    this.log.debug('Page readiness monitoring is already running');
                }
                else {
                    this.log.debug('Monitoring page readiness');
                    pageReadinessCheckPromise = performPageReadinessCheck();
                    await pageReadinessCheckPromise;
                }
            }
        };
        rpcClient.on('_rpc_forwardGetListing:', onPageChanged);
        // https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-loadEventFired
        rpcClient.once('Page.loadEventFired', onPageLoaded);
        onTargetProvisioned = async () => {
            this.log.debug('The page target has been provisioned');
            if (pageReadinessCheckPromise) {
                this.log.debug('Page readiness monitoring is already running');
            }
            else {
                this.log.debug('Monitoring page readiness');
                pageReadinessCheckPromise = performPageReadinessCheck();
                await pageReadinessCheckPromise;
            }
        };
        rpcClient.targetSubscriptions.once(rpc_1.rpcConstants.ON_TARGET_PROVISIONED_EVENT, onTargetProvisioned);
        rpcClient.send('Page.navigate', {
            url,
            appIdKey,
            pageIdKey,
        });
    });
    /** @type {B<void>} */
    const cancellationPromise = bluebird_1.default.resolve((async () => {
        try {
            await (0, property_accessors_1.getPageLoadDelay)(this);
        }
        catch (ign) { }
    })());
    try {
        await bluebird_1.default.any([cancellationPromise, pageReadinessPromise]);
    }
    finally {
        (0, property_accessors_1.setPageLoading)(this, false);
        isPageLoading = false;
        (0, property_accessors_1.setNavigatingToPage)(this, false);
        (0, property_accessors_1.setPageLoadDelay)(this, bluebird_1.default.resolve());
        if (onPageLoadedTimeout && pageReadinessPromise.isFulfilled()) {
            clearTimeout(onPageLoadedTimeout);
            onPageLoadedTimeout = null;
        }
        if (onTargetProvisioned) {
            rpcClient.targetSubscriptions.off(rpc_1.rpcConstants.ON_TARGET_PROVISIONED_EVENT, onTargetProvisioned);
        }
        if (onPageLoaded) {
            rpcClient.off('Page.loadEventFired', onPageLoaded);
        }
        if (onPageChanged) {
            rpcClient.off('_rpc_forwardGetListing:', onPageChanged);
        }
    }
    // enable console logging, so we get the events (otherwise we only
    // get notified when navigating to a local page
    try {
        await bluebird_1.default.resolve(rpcClient.send('Console.enable', {
            appIdKey: (0, property_accessors_1.getAppIdKey)(this),
            pageIdKey: (0, property_accessors_1.getPageIdKey)(this),
        }, didPageFinishLoad)).timeout(CONSOLE_ENABLEMENT_TIMEOUT_MS);
    }
    catch (err) {
        if (err instanceof bluebird_1.default.TimeoutError) {
            throw new base_driver_1.errors.TimeoutError(`Could not enable console events after the page load within ` +
                `${CONSOLE_ENABLEMENT_TIMEOUT_MS}ms. The Web Inspector/Safari may need to be restarted.`);
        }
        throw err;
    }
}
/**
 * @typedef {import('../remote-debugger').RemoteDebugger} RemoteDebugger
 */
//# sourceMappingURL=navigate.js.map