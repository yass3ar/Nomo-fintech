"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClientSimulator = void 0;
const logger_1 = __importDefault(require("../logger"));
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const net_1 = __importDefault(require("net"));
const rpc_client_1 = __importDefault(require("./rpc-client"));
const appium_ios_device_1 = require("appium-ios-device");
class RpcClientSimulator extends rpc_client_1.default {
    /**
     * @param {import('./rpc-client').RpcClientOptions & RpcClientSimulatorOptions} [opts={}]
     */
    constructor(opts = {}) {
        super(Object.assign({
            shouldCheckForTarget: false,
        }, opts));
        const { socketPath, host = '::1', port, messageProxy, } = opts;
        // host/port config for TCP communication, socketPath for unix domain sockets
        this.host = host;
        this.port = port;
        this.messageProxy = messageProxy;
        this.socket = null;
        this.socketPath = socketPath;
    }
    /**
     * @override
     */
    async connect() {
        // create socket and handle its messages
        if (this.socketPath) {
            if (this.messageProxy) {
                // unix domain socket via proxy
                logger_1.default.debug(`Connecting to remote debugger via proxy through unix domain socket: '${this.messageProxy}'`);
                this.socket = net_1.default.connect(this.messageProxy);
                // Forward the actual socketPath to the proxy
                this.socket.once('connect', () => {
                    logger_1.default.debug(`Forwarding the actual web inspector socket to the proxy: '${this.socketPath}'`);
                    // @ts-ignore socket must be efined here
                    this.socket.write(JSON.stringify({
                        socketPath: this.socketPath
                    }));
                });
            }
            else {
                // unix domain socket
                logger_1.default.debug(`Connecting to remote debugger through unix domain socket: '${this.socketPath}'`);
                this.socket = net_1.default.connect(this.socketPath);
            }
        }
        else {
            if (this.messageProxy) {
                // connect to the proxy instead of the remote debugger directly
                this.port = this.messageProxy;
            }
            // tcp socket
            logger_1.default.debug(`Connecting to remote debugger ${this.messageProxy ? 'via proxy ' : ''}through TCP: ${this.host}:${this.port}`);
            this.socket = new net_1.default.Socket();
            this.socket.connect(/** @type {number} */ (this.port), /** @type {String} */ (this.host));
        }
        this.socket.setNoDelay(true);
        this.socket.setKeepAlive(true);
        this.socket.on('close', () => {
            if (this.isConnected) {
                logger_1.default.debug('Debugger socket disconnected');
            }
            this.isConnected = false;
            this.socket = null;
        });
        this.socket.on('end', () => {
            this.isConnected = false;
        });
        this.service = await appium_ios_device_1.services.startWebInspectorService(this.udid, {
            socket: this.socket,
            isSimulator: true,
            osVersion: this.platformVersion,
            verbose: this.logAllCommunication,
            verboseHexDump: this.logAllCommunicationHexDump,
            maxFrameLength: this.webInspectorMaxFrameLength,
        });
        this.service.listenMessage(this.receive.bind(this));
        // connect the socket
        return await new bluebird_1.default((resolve, reject) => {
            // only resolve this function when we are actually connected
            // @ts-ignore socket must be defined here
            this.socket.on('connect', () => {
                logger_1.default.debug(`Debugger socket connected`);
                this.isConnected = true;
                resolve();
            });
            // @ts-ignore socket must be defined here
            this.socket.on('error', (err) => {
                if (this.isConnected) {
                    logger_1.default.error(`Socket error: ${err.message}`);
                    this.isConnected = false;
                }
                // the connection was refused, so reject the connect promise
                reject(err);
            });
        });
    }
    /**
     * @override
     */
    async disconnect() {
        if (!this.isConnected) {
            return;
        }
        logger_1.default.debug('Disconnecting from remote debugger');
        await super.disconnect();
        this.service.close();
        this.isConnected = false;
    }
    /**
     * @override
     */
    async sendMessage(cmd) {
        let onSocketError;
        return await new bluebird_1.default((resolve, reject) => {
            // handle socket problems
            onSocketError = (err) => {
                logger_1.default.error(`Socket error: ${err.message}`);
                // the connection was refused, so reject the connect promise
                reject(err);
            };
            if (!this.socket) {
                return reject(new Error('The RPC socket is not defined. Have you called `connect()` before sending a message?'));
            }
            this.socket.on('error', onSocketError);
            this.service.sendMessage(cmd);
            resolve();
        })
            .finally(() => {
            // remove this listener, so we don't exhaust the system
            try {
                // @ts-ignore socket must be defined
                this.socket.removeListener('error', onSocketError);
            }
            catch (ign) { }
        });
    }
    /**
     * @override
     */
    async receive(data) {
        if (!this.isConnected) {
            return;
        }
        if (!data) {
            return;
        }
        for (const key of ['WIRMessageDataKey', 'WIRDestinationKey', 'WIRSocketDataKey']) {
            if (!lodash_1.default.isUndefined(data[key])) {
                data[key] = data[key].toString('utf8');
            }
        }
        // @ts-ignore messageHandler must be defined
        await this.messageHandler.handleMessage(data);
    }
}
exports.RpcClientSimulator = RpcClientSimulator;
exports.default = RpcClientSimulator;
/**
 * @typedef {Object} RpcClientSimulatorOptions
 * @property {string} [socketPath]
 * @property {string} [host='::1']
 * @property {number} [port]
 * @property {any} [messageProxy]
 */
//# sourceMappingURL=rpc-client-simulator.js.map