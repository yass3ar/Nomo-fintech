"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const support_1 = require("@appium/support");
const teen_process_1 = require("teen_process");
const lodash_1 = __importDefault(require("lodash"));
const asyncbox_1 = require("asyncbox");
const helpers_1 = require("../helpers");
const logger_js_1 = __importDefault(require("../logger.js"));
const COMPANION_PGREP_PATTERN = (udid) => `${helpers_1.IDB_COMPANION_EXECUTABLE}.*--udid[[:space:]]+${udid}`;
const systemCallMethods = {};
/**
 * @typedef {Object} ConnectOptions
 *
 * @property {number} [onlineTimeout] - The number of milliseconds to wait
 * until the device under tests is online. No wait is going to be performed
 * if the timeout is not set. It is recommended to provide this value if
 * `connect` is called right after device is booted, so not all the required
 * device services have been started yet.
 */
/**
 * Initializes idb and companion processes if necessary and
 * assigns path properties. It is mandatory to call this method before
 * one can start using IDB instance,
 *
 * @this {import('../idb.js').IDB}
 * @param {ConnectOptions} opts
 * @throws {Error} If mandatory idb executables are not present on the
 * localhost or there was a failure while starting/detecting them
 */
systemCallMethods.connect = async function connect(opts = {}) {
    const { onlineTimeout, } = opts;
    const binaryPaths = {};
    for (const binary of [helpers_1.IDB_EXECUTABLE, helpers_1.IDB_COMPANION_EXECUTABLE]) {
        try {
            binaryPaths[binary] = await support_1.fs.which(binary);
        }
        catch (e) {
            throw new Error(`'${binary}' has not been found in PATH. ` +
                `Is it installed? Read https://www.fbidb.io for more details`);
        }
    }
    logger_js_1.default.debug(`Starting and connecting companion: '${binaryPaths[helpers_1.IDB_COMPANION_EXECUTABLE]}'`);
    try {
        try {
            // idb connect command looks for a running idb_companion process that associates with specified udid.
            // If not found, the command attempts to start the new idb_companion process that listens on an Unix domain socket.
            await (0, teen_process_1.exec)(helpers_1.IDB_EXECUTABLE, ['connect', this.udid]);
        }
        catch (connectionError) {
            await (0, asyncbox_1.retryInterval)(2, 100, async () => {
                await this.disconnect();
                try {
                    await (0, teen_process_1.exec)(helpers_1.IDB_EXECUTABLE, ['kill']);
                }
                catch (ign) { }
                await (0, teen_process_1.exec)(helpers_1.IDB_EXECUTABLE, ['connect', this.udid]);
            });
        }
    }
    catch (e) {
        if (e.stderr || e.stdout) {
            logger_js_1.default.debug(e.stderr || e.stdout);
        }
        throw new Error(`Cannot start ${helpers_1.IDB_EXECUTABLE} service for the device '${this.udid}'. ` +
            `Check the server log for more details.`);
    }
    logger_js_1.default.info(`Successfully established the connection to ${helpers_1.IDB_EXECUTABLE} service for '${this.udid}'`);
    if (onlineTimeout) {
        await this.waitForDevice(onlineTimeout);
    }
    this.executable.path = binaryPaths[helpers_1.IDB_EXECUTABLE];
    this.companion.path = binaryPaths[helpers_1.IDB_COMPANION_EXECUTABLE];
};
/**
 * Blocks until the device under test starts responding to idb commands.
 * The device must be booted/online and idb must be already connected for that to happen
 *
 * @this {import('../idb.js').IDB}
 * @param {number} [timeoutMs=10000] - The number of milliseconds to wait
 * until the device under tests is online. The method will return immediately
 * if the timeout is falsy
 * @throws {Error} if the device is not responding within the given timeout
 */
systemCallMethods.waitForDevice = async function waitForDevice(timeoutMs = 10000) {
    if (!timeoutMs) {
        logger_js_1.default.debug('No timeout is provided, so not waiting until the device is online');
        return;
    }
    logger_js_1.default.debug(`Waiting up to ${timeoutMs}ms for the device to be online`);
    const timer = new support_1.timing.Timer().start();
    let lastError = null;
    try {
        await (0, asyncbox_1.waitForCondition)(async () => {
            try {
                await this.exec(['ui', 'describe-all']);
                return true;
            }
            catch (e) {
                lastError = e.stderr || e.message;
                return false;
            }
        }, {
            waitMs: timeoutMs,
            intervalMs: 300,
        });
    }
    catch (e) {
        throw new Error(`The device '${this.udid}' is not responding to idb requests after ${timeoutMs}ms timeout. ` +
            `Original error: ${lastError || e.message}`);
    }
    logger_js_1.default.debug(`The device '${this.udid}' is online and ready to accept idb commands in ` +
        `${timer.getDuration().asSeconds.toFixed(3)}s`);
};
/**
 * Performs cleanup of obsolete companion processes
 * The daemon process is left untouched, because killing it might
 * potentially affect other parallel sessions. Nothing
 * is done if no obsolete processes are found.
 *
 * @this {import('../idb.js').IDB}
 */
systemCallMethods.disconnect = async function disconnect() {
    logger_js_1.default.debug(`Disconnecting ${helpers_1.IDB_EXECUTABLE} service from '${this.udid}'`);
    try {
        // idb disconnect just removes the given udid from idb state.
        // It doesn't kill the idb_companion process associated with the udid.
        await (0, teen_process_1.exec)(this.executable.path, ['disconnect', this.udid]);
    }
    catch (ign) { }
    const companionPids = await (0, helpers_1.getPids)(COMPANION_PGREP_PATTERN(this.udid));
    if (lodash_1.default.isEmpty(companionPids)) {
        return;
    }
    logger_js_1.default.debug(`Cleaning up ${companionPids.length} obsolete ${helpers_1.IDB_COMPANION_EXECUTABLE} ` +
        `process${companionPids.length === 1 ? '' : 'es'}`);
    await (0, teen_process_1.exec)('kill', ['-2', ...companionPids]);
};
/**
 * Execute the given idb command.
 *
 * @this {import('../idb.js').IDB}
 * @param {string[]} cmd - The actual idb command without arguments/params.
 * @param {string[]} [args=[]] - Optional command arguments.
 * @param {import('teen_process').TeenProcessExecOptions & {timeoutCapName?: string}} [opts={}] -
 * Additional options mapping
 * @return {Promise<string>} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.exec = async function exec(cmd, args = [], opts = {}) {
    if (!cmd) {
        throw new Error('You need to pass in a command to exec()');
    }
    cmd = lodash_1.default.isArray(cmd) ? cmd : [cmd];
    opts = lodash_1.default.cloneDeep(opts);
    // setting default timeout for each command to prevent infinite wait.
    opts.timeout = opts.timeout || this.execTimeout || helpers_1.DEFAULT_IDB_EXEC_TIMEOUT;
    opts.timeoutCapName = opts.timeoutCapName || 'execTimeout'; // For error message
    const fullArgs = [...cmd, ...this.executable.defaultArgs, ...args];
    logger_js_1.default.debug(`Running '${this.executable.path} ${support_1.util.quote(fullArgs)}'`);
    try {
        const { stdout } = await (0, teen_process_1.exec)(this.executable.path, fullArgs, opts);
        // @ts-ignore This is always a string
        return stdout;
    }
    catch (e) {
        if (support_1.util.hasValue(e.code)) {
            e.message = `Error executing ${helpers_1.IDB_EXECUTABLE}. Original error: '${e.message}'; ` +
                `Stdout: '${(e.stdout || '').trim()}'; ` +
                `Stderr: '${(e.stderr || '').trim()}'; ` +
                `Code: '${e.code}'`;
        }
        else {
            e.message = `Error executing ${helpers_1.IDB_EXECUTABLE}. Original error: '${e.message}'. ` +
                `Try to increase the ${opts.timeout}ms ${helpers_1.IDB_EXECUTABLE} execution timeout ` +
                `represented by '${opts.timeoutCapName}' capability`;
        }
        throw e;
    }
};
/**
 * Creates SubProcess instance of idb for background
 * execution.
 *
 * @this {import('../idb.js').IDB}
 * @param {string[]} [command=[]] desired idb command (e.g.: ["launch"], ["xctest", "run", "ui"])
 * @param {string[]} [args=[]] additional idb arguments
 * @param {import('teen_process').SubProcessOptions} [opts={}]
 * @returns {import('teen_process').SubProcess}
 */
systemCallMethods.createSubProcess = function createSubProcess(command = [], args = [], opts = {}) {
    const idbArgs = [...command, ...this.executable.defaultArgs, ...args];
    logger_js_1.default.debug(`Creating ${helpers_1.IDB_EXECUTABLE} subprocess with args: ${support_1.util.quote(args)}`);
    return new teen_process_1.SubProcess(this.executable.path, idbArgs, opts);
};
exports.default = systemCallMethods;
//# sourceMappingURL=system-commands.js.map