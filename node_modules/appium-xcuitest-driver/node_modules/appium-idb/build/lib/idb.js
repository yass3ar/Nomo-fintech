"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IDB = void 0;
const lodash_1 = __importDefault(require("lodash"));
const index_js_1 = __importDefault(require("./tools/index.js"));
const helpers_1 = require("./helpers");
const DEFAULT_OPTS = {
    udid: null,
    executable: {
        path: helpers_1.IDB_EXECUTABLE,
        port: null,
        grpcPort: null,
        defaultArgs: [],
    },
    logLevel: null,
    companion: {
        path: helpers_1.IDB_COMPANION_EXECUTABLE,
        port: null,
        grpcPort: null,
        logPath: null,
    },
    execTimeout: helpers_1.DEFAULT_IDB_EXEC_TIMEOUT,
    verbose: false,
};
/**
 * @typedef {Object} IdbExecutable
 * @property {string} path
 * @property {number?} [port]
 * @property {number?} [grpcPort]
 * @property {string[]} defaultArgs
 */
/**
 * @typedef {Object} IdbCompanion
 * @property {string} path
 * @property {number?} [port]
 * @property {number?} [grpcPort]
 * @property {string?} [logPath]
 */
class IDB {
    constructor(opts = {}) {
        Object.assign(this, opts);
        lodash_1.default.defaultsDeep(this, lodash_1.default.cloneDeep(DEFAULT_OPTS));
        if (!this.udid) {
            throw new Error(`UDID must be set for idb`);
        }
        this.executable.defaultArgs.push('--udid', this.udid);
        if (this.logLevel) {
            this.executable.defaultArgs.push('--log', this.logLevel);
        }
    }
}
exports.IDB = IDB;
// add all the methods to the IDB prototype
for (const [fnName, fn] of lodash_1.default.toPairs(index_js_1.default)) {
    IDB.prototype[fnName] = fn;
}
exports.default = IDB;
//# sourceMappingURL=idb.js.map