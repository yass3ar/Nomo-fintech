"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installApp = installApp;
exports.getUserInstalledBundleIdsByBundleName = getUserInstalledBundleIdsByBundleName;
exports.isAppInstalled = isAppInstalled;
exports.removeApp = removeApp;
exports.launchApp = launchApp;
exports.terminateApp = terminateApp;
exports.isAppRunning = isAppRunning;
exports.scrubApp = scrubApp;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const support_1 = require("@appium/support");
const bluebird_1 = __importDefault(require("bluebird"));
const asyncbox_1 = require("asyncbox");
/**
 * Install valid .app package on Simulator.
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} app - The path to the .app package.
 */
async function installApp(app) {
    return await this.simctl.installApp(app);
}
/**
 * Returns user installed bundle ids which has 'bundleName' in their Info.Plist as 'CFBundleName'
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleName - The bundle name of the application to be checked.
 * @return {Promise<string[]>} - The list of bundle ids which have 'bundleName'
 */
async function getUserInstalledBundleIdsByBundleName(bundleName) {
    const appsRoot = path_1.default.resolve(this.getDir(), 'Containers', 'Bundle', 'Application');
    // glob all Info.plist from simdir/data/Containers/Bundle/Application
    const infoPlists = await support_1.fs.glob('*/*.app/Info.plist', {
        cwd: appsRoot,
        absolute: true,
    });
    if (lodash_1.default.isEmpty(infoPlists)) {
        return [];
    }
    const bundleInfoPromises = [];
    for (const infoPlist of infoPlists) {
        bundleInfoPromises.push((async () => {
            try {
                return await support_1.plist.parsePlistFile(infoPlist);
            }
            catch (ign) { }
        })());
    }
    const bundleInfos = (await bluebird_1.default.all(bundleInfoPromises)).filter(lodash_1.default.isPlainObject);
    const bundleIds = bundleInfos
        .filter(({ CFBundleName }) => CFBundleName === bundleName)
        .map(({ CFBundleIdentifier }) => CFBundleIdentifier);
    if (lodash_1.default.isEmpty(bundleIds)) {
        return [];
    }
    this.log.debug(`The simulator has ${support_1.util.pluralize('bundle', bundleIds.length, true)} which ` +
        `have '${bundleName}' as their 'CFBundleName': ${JSON.stringify(bundleIds)}`);
    return bundleIds;
}
/**
 * Verify whether the particular application is installed on Simulator.
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleId - The bundle id of the application to be checked.
 * @return {Promise<boolean>} True if the given application is installed.
 */
async function isAppInstalled(bundleId) {
    try {
        const appContainer = await this.simctl.getAppContainer(bundleId);
        if (!appContainer.endsWith('.app')) {
            return false;
        }
        return await support_1.fs.exists(appContainer);
    }
    catch (err) {
        // get_app_container subcommand fails for system applications,
        // so we try the hidden appinfo subcommand, which prints correct info for
        // system/hidden apps
        try {
            const info = await this.simctl.appInfo(bundleId);
            return info.includes('ApplicationType');
        }
        catch (ign) { }
    }
    return false;
}
/**
 * Uninstall the given application from the current Simulator.
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleId - The buindle ID of the application to be removed.
 */
async function removeApp(bundleId) {
    await this.simctl.removeApp(bundleId);
}
/**
 * Starts the given application on Simulator
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleId - The buindle ID of the application to be launched
 * @param {import('../types').LaunchAppOptions} [opts={}]
 */
async function launchApp(bundleId, opts = {}) {
    await this.simctl.launchApp(bundleId);
    const { wait = false, timeoutMs = 10000, } = opts;
    if (!wait) {
        return;
    }
    try {
        await (0, asyncbox_1.waitForCondition)(async () => await this.isAppRunning(bundleId), {
            waitMs: timeoutMs,
            intervalMs: 300
        });
    }
    catch (e) {
        throw new Error(`App '${bundleId}' is not runnning after ${timeoutMs}ms timeout.`);
    }
}
/**
 * Stops the given application on  Simulator.
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleId - The buindle ID of the application to be stopped
 */
async function terminateApp(bundleId) {
    await this.simctl.terminateApp(bundleId);
}
/**
 * Check if app with the given identifier is running.
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleId - The buindle ID of the application to be checked.
 */
async function isAppRunning(bundleId) {
    return (await this.ps()).some(({ name }) => name === bundleId);
}
/**
 * Scrub (delete the preferences and changed files) the particular application on Simulator.
 * The app will be terminated automatically if it is running.
 *
 * @this {CoreSimulatorWithApps}
 * @param {string} bundleId - Bundle identifier of the application.
 * @throws {Error} if the given app is not installed.
 */
async function scrubApp(bundleId) {
    const appDataRoot = await this.simctl.getAppContainer(bundleId, 'data');
    const appFiles = await support_1.fs.glob('**/*', {
        cwd: appDataRoot,
        nodir: true,
        absolute: true,
    });
    this.log.info(`Found ${appFiles.length} ${bundleId} app ${support_1.util.pluralize('file', appFiles.length, false)} to scrub`);
    if (lodash_1.default.isEmpty(appFiles)) {
        return;
    }
    try {
        await this.terminateApp(bundleId);
    }
    catch (ign) { }
    await bluebird_1.default.all(appFiles.map((p) => support_1.fs.rimraf(p)));
}
/**
 * @typedef {import('../types').CoreSimulator & import('../types').InteractsWithApps} CoreSimulatorWithApps
 */
//# sourceMappingURL=applications.js.map