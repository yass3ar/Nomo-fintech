export default AfcService;
export class AfcService extends BaseServiceSocket {
    constructor(socketClient: any);
    _splitter: LengthBasedSplitter;
    _decoder: AfcDecoder;
    _encoder: AfcEncoder;
    _responseCallbacks: {};
    _packetNumber: number;
    _handleData(data: any): void;
    /**
     * Creates a directory relative to an already existing directory
     * @param {string} path The path in unix format
     */
    createDirectory(path: string): Promise<void>;
    /**
     * Deletes are directory completely even it has content inside. This is an implementation of 'rm -r {path}'
     * @param {string} path The path in unix format
     */
    deleteDirectory(path: string): Promise<void>;
    /**
     * Lists a directory's contents and returns them in an array
     * @param {string} path The path in unix format
     * @return {Promise<string[]>}
     */
    listDirectory(path: string): Promise<string[]>;
    /**
     * Opens a file and creates a file handle
     * @param {string} path The path in unix format
     * @param {number} mode The file mode that will be used
     * @return {Promise<number>}
     */
    openFile(path: string, mode: number): Promise<number>;
    /**
     * Opens a file and creates a nodejs write stream
     * @param {string} filePath The path in unix format
     * @param {Object} opts The regular options that are passed to a Stream.Writable
     * @return {Promise<AfcWritableFileStream>}
     */
    createWriteStream(filePath: string, opts: any): Promise<AfcWritableFileStream>;
    /**
     * Opens a file and creates a nodejs read stream
     * @param {string} filePath The path in unix format
     * @param {Object} options The regular options that are passed to a Stream.Readable
     * @return {Promise<AfcReadableFileStream>}
     */
    createReadStream(filePath: string, options: any): Promise<AfcReadableFileStream>;
    /**
     * Closes the file handle
     * @param {number} fileHandle the file handle to be closed
     */
    closeFileHandle(fileHandle: number): Promise<void>;
    /**
     * Writes the buffer into the given file handle
     * @param {number} fileHandle The file handle to be used
     * @param {Buffer} buffer The buffer that will be written
     */
    writeFile(fileHandle: number, buffer: Buffer): Promise<void>;
    /**
     * Read a certain length of buffer from the file handle
     * @param {number} fileHandle The file handle to be used
     * @param {number} length The length that wants to be read from the file handle
     * @return {Promise<Buffer>}
     */
    readFile(fileHandle: number, length: number): Promise<Buffer>;
    /**
     * Get the file info of the given path
     * @param {string} path The path in unix format
     * @return {Promise<FileInfo>}
     */
    getFileInfo(path: string): Promise<FileInfo>;
    /** The callback function which will be called during the directory walking
     * @callback WalkDirCallback
     * @param {string} itemPath The path of the file or folder
     * @param {boolean} isDirectory Shows if it is a directory or a file
    */
    /**
     *
     * @param {string} dir The path in unix format
     * @param {boolean} recursive Sets whether to follow sub directories or not
     * @param {WalkDirCallback} onPath The callback to be called when a new path is found
     */
    walkDir(dir: string, recursive: boolean, onPath: (itemPath: string, isDirectory: boolean) => any): Promise<void>;
    _checkStatus(res: any): void;
    _parseArray(buffer: any): any[];
    _parseObject(buffer: any): {};
    _createPacketPromise(message: any, timeout?: number): {
        packetNumber: number;
        response: B<any>;
    };
}
export const AFC_SERVICE_NAME: "com.apple.afc";
import { BaseServiceSocket } from '../base-service';
import LengthBasedSplitter from '../util/transformer/length-based-splitter';
import AfcDecoder from './transformer/afcdecoder';
import AfcEncoder from './transformer/afcencoder';
import { AfcWritableFileStream } from './streams';
import { AfcReadableFileStream } from './streams';
declare class FileInfo {
    constructor({ st_size, st_blocks, st_nlink, st_ifmt, st_mtime, st_birthtime }: {
        st_size: any;
        st_blocks: any;
        st_nlink: any;
        st_ifmt: any;
        st_mtime: any;
        st_birthtime: any;
    });
    size: number;
    blocks: number;
    nlink: number;
    ifmt: any;
    mtimeMs: number;
    birthtimeMs: number;
    isDirectory(): boolean;
    isFile(): boolean;
}
import B from 'bluebird';
//# sourceMappingURL=index.d.ts.map