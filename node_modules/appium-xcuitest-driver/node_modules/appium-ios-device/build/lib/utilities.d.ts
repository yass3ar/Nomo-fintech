export type DeviceTime = {
    /**
     * Unix timestamp in seconds since 1970-01-01T00:00:00Z
     */
    timestamp: number;
    /**
     * The difference in minutes between the UTC time and the local device time.
     * Can be negative.
     */
    utcOffset: number;
    /**
     * Time zone name configured on the device, for example `Europe/Paris`
     */
    timeZone: string;
};
/**
 * Retrieves the udids of the connected devices
 *
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<string[]>} The list of device serial numbers (udid) or
 * an empty list if no devices are connected
 */
export function getConnectedDevices(socket?: import("net").Socket | null): Promise<string[]>;
/**
 * Retrieves the os version of the device
 *
 * @param {string} udid Device UDID
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<string>}
 */
export function getOSVersion(udid: string, socket?: import("net").Socket | null): Promise<string>;
/**
 * Retrieves the name of the device
 *
 * @param {string} udid Device UDID
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<string>}
 */
export function getDeviceName(udid: string, socket?: import("net").Socket | null): Promise<string>;
/**
 * @typedef {Object} DeviceTime
 *
 * @property {number} timestamp Unix timestamp in seconds since 1970-01-01T00:00:00Z
 * @property {number} utcOffset The difference in minutes between the UTC time and the local device time.
 * Can be negative.
 * @property {string} timeZone Time zone name configured on the device, for example `Europe/Paris`
 */
/**
 * Retrieves the local time from the device under test
 *
 * @param {string} udid Device UDID
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<DeviceTime>}
 */
export function getDeviceTime(udid: string, socket?: import("net").Socket | null): Promise<DeviceTime>;
/**
 * Starts a lockdown session on the given device
 *
 * @param {string} udid Device UDID
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<import('./lockdown').Lockdown>}
 */
export function startLockdownSession(udid: string, socket?: import("net").Socket | null): Promise<import("./lockdown").Lockdown>;
/**
 * Connects to a given port
 *
 * @param {string} udid Device UDID
 * @param {number} port Port to connect
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<NodeJS.Socket|Object>} The socket or the object returned in the callback if the callback function exists
 */
export function connectPort(udid: string, port: number, socket?: import("net").Socket | null): Promise<NodeJS.Socket | any>;
/**
 * Connects to a given port with the certs and keys used in the pairing process
 *
 * @param {string} udid Device UDID
 * @param {number} port Port to connect
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @param {boolean} handshakeOnly only handshake and return the initial socket
 * @returns {Promise<import('tls').TLSSocket|Object>} The socket or the object returned in the callback if the callback function exists
 */
export function connectPortSSL(udid: string, port: number, socket?: import("net").Socket | null, handshakeOnly?: boolean): Promise<import("tls").TLSSocket | any>;
/**
 * Returns all available device values
 * @param {string} udid Device UDID
 * @param {import('net').Socket?} socket the socket of usbmuxd. It will default to /var/run/usbmuxd if it is not passed
 * @returns {Promise<any>} Returns available default device values via lockdown.
 * e.g.
 * {
 *   "BasebandCertId"=>3840149528,
 *   "BasebandKeyHashInformation"=>
 *     {"AKeyStatus"=>2,
 *     "SKeyHash"=>{
 *       "type"=>"Buffer",
 *       "data"=>[187, 239, ....]},
 *     "SKeyStatus"=>0},
 *   "BasebandSerialNumber"=>{"type"=>"Buffer", "data"=>[...]},
 *   "BasebandVersion"=>"11.01.02",
 *   "BoardId"=>2,
 *   "BuildVersion"=>"19C56",
 *   "CPUArchitecture"=>"arm64",
 *   "ChipID"=>32768,
 *   "DeviceClass"=>"iPhone",
 *   "DeviceColor"=>"#c8caca",
 *   "DeviceName"=>"kazu",
 *   "DieID"=>1111111111111,
 *   "HardwareModel"=>"N69uAP",
 *   "HasSiDP"=>true,
 *   "PartitionType"=>"GUID_partition_scheme",
 *   "ProductName"=>"iPhone OS",
 *   "ProductType"=>"iPhone8,4",
 *   "ProductVersion"=>"15.2",
 *   "ProductionSOC"=>true,
 *   "ProtocolVersion"=>"2",
 *   "SupportedDeviceFamilies"=>[1],
 *   "TelephonyCapability"=>true,
 *   "UniqueChipID"=>1111111111111,
 *   "UniqueDeviceID"=>"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
 *   "WiFiAddress"=>"00:00:00:00:00:00"
 * }
 */
export function getDeviceInfo(udid: string, socket?: import("net").Socket | null): Promise<any>;
/**
 * Search developer image for device based on given repo. If certain file was found, this would automatic download,
 * unzip and return the path of developer image and signature file.
 *
 * Developer images and signature files should be put into a zip file that matches this regular expression:
 * `\d+\.\d+(\(([\w_|.()])+\))?.zip`. The image file should be named to `DeveloperDiskImage.dmg`,
 *  and the signature file should be named to `DeveloperDiskImage.dmg.signature`.
 * Both files should be placed into same folder.
 * @param {string} udid
 * @param {import('./imagemounter/utils/list_developer_image').ImageFromGithubRepo} opts
 * github repo option, `githubRepo` .
 * @returns {Promise<import('./imagemounter/utils/list_developer_image').ImagePath>}
 * @throws If opts error or failed on searching image
 */
export function fetchImageFromGithubRepo(udid: string, opts: import("./imagemounter/utils/list_developer_image").ImageFromGithubRepo): Promise<import("./imagemounter/utils/list_developer_image").ImagePath>;
//# sourceMappingURL=utilities.d.ts.map