export const INSTRUMENT_CHANNEL: Readonly<{
    DEVICE_INFO: "com.apple.instruments.server.services.deviceinfo";
    PROCESS_CONTROL: "com.apple.instruments.server.services.processcontrol";
    SYSMONTAP: "com.apple.instruments.server.services.sysmontap";
    NETWORKING: "com.apple.instruments.server.services.networking";
    MOBILE_NOTIFICATIONS: "com.apple.instruments.server.services.mobilenotifications";
    GRAPHICS_OPENGL: "com.apple.instruments.server.services.graphics.opengl";
    APPLICATION_LISTING: "com.apple.instruments.server.services.device.applictionListing";
    CONDITION_INDUCER: "com.apple.instruments.server.services.ConditionInducer";
}>;
/**
 * The callback function which will be called during the data transmission in instrument serve
 */
export type DTXCallback = (object: DTXMessage) => any;
/** The callback function which will be called during the data transmission in instrument serve
 * @callback DTXCallback
 * @param {DTXMessage} object
*/
export class InstrumentService extends BaseServiceSocket {
    /**
     * @param {import('net').Socket} socketClient  DTXMessage.selector
     * @param {DTXCallback?} event if empty will ignore any messages
     */
    constructor(socketClient: import("net").Socket, event?: DTXCallback | null);
    _undefinedCallback: DTXCallback | null;
    _callbacks: events<[never]>;
    _channelCallbacks: events<[never]>;
    _replyQueues: any;
    _replyQueuesRevoker: () => void;
    _channels: {};
    _nextIdentifier: number;
    _encoder: DTXEncoder;
    _decoder: DTXDecoder;
    /**
     * If the selector is registered, The message of the selector event will be returned. refer to this._handleData
     * @param {string} selector  Listen for return DTXMessage.selector data
     * @param {DTXCallback} event
     */
    registerSelectorCallback(selector: string, event: DTXCallback): void;
    /**
     * If the event is registered, all unregistered messages will be returned to event. refer to this._handleData
     * @param {DTXCallback} event
     */
    registerUndefinedCallback(event: DTXCallback): void;
    /**
     * If the event is registered, this channel {CHANNEL} messages will be returned to event. refer to this._handleData
     * It's actually listening for int channelCode. In this._channel object to record channel key and int value
     * @param {string} channel instruments service channel e.g: INSTRUMENT_CHANNEL.DEVICE_INFO.
     * @param {DTXCallback} event
     */
    registerChannelCallback(channel: string, event: DTXCallback): Promise<void>;
    /**
     * Event will be registered to socket client lifecycle
     * @param {string} eventName
     * @param {(message: any | null) => void} event
     */
    registerLifecycleCallback(eventName: string, event: (message: any | null) => void): void;
    /**
     * Create a service channel, data transmission of the service will use this channelCode
     * @param {string} channel  instruments service channel e.g: INSTRUMENT_CHANNEL.DEVICE_INFO
     * @returns {Promise<number|*>} instruments service channel code for data transmission
     */
    makeChannel(channel: string): Promise<number | any>;
    /**
     * In general, we call this method to start the instrument dtx service
     * @param {string} channel instrument dtx service e.g: INSTRUMENT_CHANNEL.DEVICE_INFO
     * @param {string} selector instrument service method name (reflection calls)
     * @param {...any | DTXMessageAuxBuffer} auxiliaries parameters required by selector. If auxiliaries are passed in using
     * the DTXMessageAuxBuffer type, all the variables should be manually assembled into only one DTXMessageAuxBuffer instance.
     * @returns {Promise<DTXMessage>}
     * exampleï¼š
     * instrumentService.callChannel(INSTRUMENT_CHANNEL.PROCESS_CONTROL,
          'launchSuspendedProcessWithDevicePath:bundleIdentifier:environment:arguments:options:', '',
          bundleID, {}, [], {'StartSuspendedKey': 0, 'KillExisting': 1}
     */
    callChannel(channel: string, selector: string, ...auxiliaries: (any | DTXMessageAuxBuffer)[]): Promise<DTXMessage>;
    _callChannel(sync: any, channelCode: any, selector: any, ...auxiliaries: any[]): Promise<any>;
    /**
     * Handling registered asynchronous message callbacks
     * @param {DTXMessage} data
     * @private
     */
    private _handleData;
    /**
     * return a empty ack message
     * @param {DTXMessage} data
     */
    _replyAck(data: DTXMessage): void;
    dispose(): void;
}
export const INSTRUMENT_SERVICE_NAME_VERSION_14: "com.apple.instruments.remoteserver.DVTSecureSocketProxy";
export const INSTRUMENT_SERVICE_NAME: "com.apple.instruments.remoteserver";
import { DTXMessage } from './headers';
import { BaseServiceSocket } from '../base-service';
import events from 'events';
import { DTXEncoder } from './transformer/dtx-encode';
import { DTXDecoder } from './transformer/dtx-decode';
import { DTXMessageAuxBuffer } from './headers';
//# sourceMappingURL=index.d.ts.map