export type DTXMessageOptions = {
    selector: any;
    /**
     * packet transmission sequence, this value is incremented for each request
     */
    identifier: number;
    /**
     * the data transmission of the service will use this channel code.
     * Each service has a separate channel
     */
    channelCode: number;
    /**
     * DTXMessageAuxBuffer.length(nullable) + selectorBuffer.length(nullable)
     */
    payloadLength: number | null;
    /**
     * if true reply a ack message
     */
    expectsReply: boolean;
    /**
     * raw data +1 indicate a reply message
     */
    conversationIndex: number;
    /**
     * message status
     */
    flags: number;
};
export type DTXMessagePayloadHeaderObject = {
    /**
     * message status
     */
    flags: number;
    /**
     * DTXMessageAuxBuffer.length(nullable)
     */
    auxLength: number;
    /**
     * DTXMessageAuxBuffer.length(nullable) + selectorBuffer.length
     */
    totalLength: bigint;
};
/**
 * DTXMessageHeader length 32
 * struct DTXMessageHeader {
 *     u32 magic DTX_MESSAGE_HEADER_MAGIC
 *     u32 headerLength
 *     u16 fragmentId   packet number
 *     u16 fragmentCount  packets total number
 *     u32 payloadLength
 *     u32 identifier
 *     u32 conversationIndex
 *     u32 channel
 *     u32 expectsReply
 *     }
 */
/**
 * @typedef {Object} DTXMessageOptions
 * @property {any} selector
 * @property {number} identifier packet transmission sequence, this value is incremented for each request
 * @property {number} channelCode the data transmission of the service will use this channel code.
 * Each service has a separate channel
 * @property {number?} payloadLength DTXMessageAuxBuffer.length(nullable) + selectorBuffer.length(nullable)
 * @property {boolean} expectsReply if true reply a ack message
 * @property {number} conversationIndex  raw data +1 indicate a reply message
 * @property {number} flags message status
 */
export class DTXMessageHeader {
    /**
     * @param {Partial<DTXMessageOptions>} data
     * @returns {Buffer} DTXMessageHeaderBuffer
     */
    static build(data: Partial<DTXMessageOptions>): Buffer;
    /**
     * @param headerBuffer DTXMessageHeaderBuffer
     * @returns {Object}
     */
    static parse(headerBuffer: any): any;
}
/**
 * DTXMessagePayloadHeader length 16
 * struct DTXMessageHeader {
 *     u32 flags FLAG_TYPES
 *     u32 auxLength
 *     u64 totalLength
 *     }
 */
/**
 * @typedef {Object} DTXMessagePayloadHeaderObject
 * @property {number} flags message status
 * @property {number} auxLength DTXMessageAuxBuffer.length(nullable)
 * @property {bigint} totalLength DTXMessageAuxBuffer.length(nullable) + selectorBuffer.length
 */
export class DTXMessagePayloadHeader {
    /**
     * @param data {DTXMessagePayloadHeaderObject}
     * @returns {Buffer} DTXMessagePayloadHeaderBuffer
     */
    static build(data: DTXMessagePayloadHeaderObject): Buffer;
    /**
     * @param headerBuffer
     * @returns {DTXMessagePayloadHeaderObject}
     */
    static parse(headerBuffer: any): DTXMessagePayloadHeaderObject;
}
export class DTXMessageAuxBuffer {
    _buf: Buffer;
    /**
     * @param {number} value
     */
    appendInt(value: number): void;
    /**
     * @param {bigint} value
     */
    appendLong(value: bigint): void;
    /**
     * @param {number} value
     */
    appendSignedInt(value: number): void;
    /**
     * @param {bigint} value
     */
    appendSignedLong(value: bigint): void;
    /**
     * @param {Object} value
     */
    appendObject(value: any): void;
    getBytes(): Buffer;
}
export class DTXMessageAux {
    /**
     * Parses nskeyed Buffer into js array
     * @param {Buffer} headerBuffer
     * @param {DTXMessagePayloadHeaderObject} payloadHeader
     * @returns {any[]}
     */
    static parse(headerBuffer: Buffer, payloadHeader: DTXMessagePayloadHeaderObject): any[];
    /**
     * @param {any[] | DTXMessageAuxBuffer} data
     */
    constructor(data?: any[] | DTXMessageAuxBuffer);
    data: any[] | DTXMessageAuxBuffer;
    /**
     * JS Array to Apple NSKeyed Buffer
     * @returns {Buffer}
     */
    build(): Buffer;
}
export class DTXMessage {
    /**
     * Parses DTX buffer into an js object. Returned in DTXDecoder Stream.Transform
     * @param {Buffer} headerBuf  DTXMessageHeader buffer
     * @param {Buffer} payloadBuf  PayloadHeaderBuffer + DTXMessageAuxBuffer(nullable) + selectorBuffer(nullable)
     * @returns {DTXMessage}
     */
    static parse(headerBuf: Buffer, payloadBuf: Buffer): DTXMessage;
    /**
     * @param {Partial<DTXMessageOptions>} opts
     */
    constructor(opts?: Partial<DTXMessageOptions>);
    _messageHeader: any;
    _payloadHeader: any;
    _identifier: number | undefined;
    _channelCode: number | undefined;
    _expectsReply: boolean | undefined;
    _selector: any;
    _conversationIndex: number;
    _flags: number;
    auxiliaries: DTXMessageAux;
    /**
     * get DTXMessageHeader identifier. Packet transmission sequence
     * @returns {number}
     */
    get identifier(): number;
    /**
     * get DTXMessageHeader channelCode.
     * Packet transmission channelCode. Use this value to distinguish when there are multiple channels
     * call this method `InstrumentService.registerChannelCallback` get the channel message
     * @returns {number}
     */
    get channelCode(): number;
    /**
     * get DTXMessageHeader expectsReply. Whether to need ack message
     * if expectsReply is true must reply ack message
     * @returns {boolean}
     */
    get expectsReply(): boolean;
    /**
     * @param data
     */
    set selector(data: any);
    /**
     * call this method `InstrumentService.registerSelectorCallback` get the selector message
     * @returns {*} Unknown data
     */
    get selector(): any;
    /**
     * get DTXMessageHeader conversationIndex
     * @returns {number}
     */
    get conversationIndex(): number;
    /**
     * DTXMessage Buffer: DTXMessageHeader + PayloadHeader + DTXMessageAuxBuffer(nullable) + selector(nullable)
     * @returns {Buffer}
     */
    build(): Buffer;
}
export const DTX_MESSAGE_PAYLOAD_HEADER_LENGTH: 16;
export const DTX_MESSAGE_HEADER_LENGTH: 32;
export const DTX_MESSAGE_HEADER_MAGIC: 524114809;
export const DTX_MESSAGE_HEADER_MAGIC_LEN: 4;
export const FLAG_TYPES: Readonly<{
    push: 0;
    recv: 1;
    send: 2;
    reply: 3;
}>;
//# sourceMappingURL=headers.d.ts.map