"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DTXDecoder = void 0;
const stream_1 = __importDefault(require("stream"));
const headers_1 = require("../headers");
const logger_1 = __importDefault(require("../../logger"));
class DTXDecoder extends stream_1.default.Transform {
    constructor() {
        super({ objectMode: true });
        this._dtxManager = {};
        this.buffer = Buffer.allocUnsafe(0);
        this.cursor = 0;
        this.header = undefined;
    }
    _transform(data, encoding, onData) {
        this._decode(data);
        onData();
    }
    _decode(data) {
        // Merge packets
        this.buffer = Buffer.concat([this.buffer.slice(this.cursor, this.buffer.length), data]);
        this.cursor = 0;
        while (this.cursor < this.buffer.length) {
            const magic = this._recv(headers_1.DTX_MESSAGE_HEADER_MAGIC_LEN);
            if (!magic) {
                return;
            }
            this.cursor -= headers_1.DTX_MESSAGE_HEADER_MAGIC_LEN;
            if (magic && magic.readUInt32LE(0) === headers_1.DTX_MESSAGE_HEADER_MAGIC) {
                const headerBuffer = this._recv(headers_1.DTX_MESSAGE_HEADER_LENGTH);
                if (!headerBuffer) {
                    return;
                }
                this.header = headers_1.DTXMessageHeader.parse(headerBuffer);
                if (this.header.fragmentId === 0) {
                    // only the 0th fragment contains a message header
                    if (!(this.header.channel in this._dtxManager)) {
                        this._dtxManager[this.header.channel] = { headerBuffer, payloadBuffer: Buffer.allocUnsafe(0) };
                    }
                    if (this.header.fragmentCount > 1) {
                        // Continue to get the next message fragments
                        continue;
                    }
                }
            }
            const bodyBuffer = this._recv(this.header.payloadLength);
            if (!bodyBuffer) {
                return;
            }
            if (this._dtxManager[this.header.channel]) {
                this._dtxManager[this.header.channel].payloadBuffer = Buffer.concat([this._dtxManager[this.header.channel].payloadBuffer, bodyBuffer]);
            }
            if (this.header.fragmentId === (this.header.fragmentCount - 1)) {
                data = this._dtxManager[this.header.channel];
                delete this._dtxManager[this.header.channel];
                if (data) {
                    try {
                        const dtxMessage = headers_1.DTXMessage.parse(data.headerBuffer, data.payloadBuffer);
                        this.push(dtxMessage);
                    }
                    catch (e) {
                        logger_1.default.debug(e.stack);
                        logger_1.default.error(`Skipped decoding of an unparseable DTXMessage: ${e.message}`);
                    }
                }
            }
        }
        this.cursor = 0;
        this.buffer = Buffer.allocUnsafe(0);
    }
    _recv(length) {
        if (this.buffer.length < this.cursor + length) {
            return null;
        }
        const buf = this.buffer.slice(this.cursor, this.cursor + length);
        this.cursor += length;
        return buf;
    }
}
exports.DTXDecoder = DTXDecoder;
//# sourceMappingURL=dtx-decode.js.map