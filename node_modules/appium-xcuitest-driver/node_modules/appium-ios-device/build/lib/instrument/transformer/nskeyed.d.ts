export type XCTestConfigurationPlist = {
    testBundleURL: string | NSURL;
    sessionIdentifier: string | NSUUID;
    productModuleName: string | null;
    targetApplicationBundleID: string | null;
    targetApplicationArguments: string[] | null;
    testsToRun: string[] | null;
    testsToSkip: string[] | null;
};
/**
 * Update unknown NSKeyedArchive types for packing/unpacking
 * @param {String} name packing/unpacking key name
 * @param {BaseArchiveHandler} subClass inherit from BaseArchiveHandler class
 */
export function updateNSKeyedArchiveClass(name: string, subClass: BaseArchiveHandler): void;
/**
 * This class must be inherited when creating an archive/unarchive subclass
 * And you need to call `updateNSKeyedArchiveClass` add subclass to archive/unarchive object
 */
export class BaseArchiveHandler {
    /**
     * some of the classes may have to add 'NSObject' or maybe more in $classes while encoding.
     */
    additionClasses: any[];
    /**
     * @param {ArchivedObject} archive
     */
    decodeArchive(archive: ArchivedObject): void;
    /**
     * @param {Object} obj  an instance of this Â§class
     * @param {ArchivingObject} archive
     */
    encodeArchive(obj: any, archive: ArchivingObject): void;
}
export class NSURL extends BaseArchiveHandler {
    /**
     * @param {*} base
     * @param {string} relative usually ios device relative path e.g: file://xx/
     */
    constructor(base: any, relative: string);
    _base: any;
    _relative: string;
    additionClasses: string[];
    decodeArchive(archive: any): {
        $class: string;
        base: any;
        relative: any;
    };
    encodeArchive(obj: any, archive: any): void;
}
export class NSUUID extends BaseArchiveHandler {
    /**
     * @param {string} data uuid format data e.g:00000000-0000-0000-0000-000000000000
     */
    constructor(data: string);
    _data: string;
    additionClasses: string[];
    decodeArchive(archive: any): string;
    encodeArchive(obj: any, archive: any): void;
}
export class NSDate extends BaseArchiveHandler {
    /**
     * @param {number} data timestamp in seconds
     */
    constructor(data: number);
    _data: number;
    decodeArchive(archive: any): any;
    encodeArchive(obj: any, archive: any): void;
}
/**
 * @typedef {Object} XCTestConfigurationPlist
 * @property {string | NSURL} testBundleURL
 * @property {string | NSUUID} sessionIdentifier
 * @property {string?} productModuleName
 * @property {string?} targetApplicationBundleID
 * @property {string[]?} targetApplicationArguments
 * @property {string[]?} testsToRun
 * @property {string[]?} testsToSkip
 */
export class XCTestConfiguration extends BaseArchiveHandler {
    static _default: {
        aggregateStatisticsBeforeCrash: {
            XCSuiteRecordsKey: {};
        };
        automationFrameworkPath: string;
        baselineFileRelativePath: undefined;
        baselineFileURL: undefined;
        defaultTestExecutionTimeAllowance: undefined;
        disablePerformanceMetrics: boolean;
        emitOSLogs: boolean;
        formatVersion: number;
        gatherLocalizableStringsData: boolean;
        initializeForUITesting: boolean;
        maximumTestExecutionTimeAllowance: undefined;
        productModuleName: string;
        randomExecutionOrderingSeed: undefined;
        reportActivities: boolean;
        reportResultsToIDE: boolean;
        systemAttachmentLifetime: number;
        targetApplicationArguments: never[];
        targetApplicationBundleID: undefined;
        targetApplicationEnvironment: undefined;
        targetApplicationPath: string;
        testApplicationDependencies: {};
        testApplicationUserOverrides: undefined;
        testBundleRelativePath: undefined;
        testExecutionOrdering: number;
        testTimeoutsEnabled: boolean;
        testsDrivenByIDE: boolean;
        testsMustRunOnMainThread: boolean;
        testsToRun: undefined;
        testsToSkip: undefined;
        treatMissingBaselinesAsFailures: boolean;
        userAttachmentLifetime: number;
    };
    /**
     * @param {XCTestConfigurationPlist} data
     */
    constructor(data: XCTestConfigurationPlist);
    _data: {
        testBundleURL: string | NSURL;
        sessionIdentifier: string | NSUUID;
        productModuleName: string | null;
        targetApplicationBundleID: string | null;
        targetApplicationArguments: string[] | null;
        testsToRun: string[] | null;
        testsToSkip: string[] | null;
        aggregateStatisticsBeforeCrash: {
            XCSuiteRecordsKey: {};
        };
        automationFrameworkPath: string;
        baselineFileRelativePath: undefined;
        baselineFileURL: undefined;
        defaultTestExecutionTimeAllowance: undefined;
        disablePerformanceMetrics: boolean;
        emitOSLogs: boolean;
        formatVersion: number;
        gatherLocalizableStringsData: boolean;
        initializeForUITesting: boolean;
        maximumTestExecutionTimeAllowance: undefined;
        randomExecutionOrderingSeed: undefined;
        reportActivities: boolean;
        reportResultsToIDE: boolean;
        systemAttachmentLifetime: number;
        targetApplicationEnvironment: undefined;
        targetApplicationPath: string;
        testApplicationDependencies: {};
        testApplicationUserOverrides: undefined;
        testBundleRelativePath: undefined;
        testExecutionOrdering: number;
        testTimeoutsEnabled: boolean;
        testsDrivenByIDE: boolean;
        testsMustRunOnMainThread: boolean;
        treatMissingBaselinesAsFailures: boolean;
        userAttachmentLifetime: number;
    };
    getBytes(): Buffer;
}
/**
 * Parses NSKeyed Buffer into JS Object
 * @param {Buffer} inputBytes NSKeyed Buffer
 * @returns {Object} JS Object
 */
export function unarchive(inputBytes: Buffer): any;
/**
 * Creates NSKeyed Buffer from an object
 * @param {Object} inputObject
 * @returns {Buffer} NSKeyed Buffer
 */
export function archive(inputObject: any): Buffer;
declare class ArchivedObject {
    /**
     * Stateful wrapper around Archive for an object being archived.
     * @param {Object} object
     * @param {Unarchive} unarchiver
     * @constructor
     */
    constructor(object: any, unarchiver: Unarchive);
    object: any;
    _unarchiver: Unarchive;
    decodeIndex(index: any): any;
    decode(key: any): any;
}
declare class ArchivingObject {
    /**
     * Stateful wrapper around Unarchive for an archived object
     * @param {Object} object
     * @param {Archive} archiver
     * @constructor
     */
    constructor(object: any, archiver: Archive);
    _archiveObj: any;
    _archiver: Archive;
    encode(key: any, val: any): void;
}
/**
 * Capable of unpacking an archived object tree in the NSKeyedArchive format.
 * Apple's implementation can be found here:
 * https://github.com/apple/swift-corelibs-foundation/blob/main/Sources/Foundation/NSKeyedUnarchiver.swift
 */
declare class Unarchive {
    constructor(inputBytes: any);
    input: any;
    unpackedUids: {};
    topUID: any;
    objects: any[];
    unpackArchiveHeader(): void;
    /**
     * use the UNARCHIVE_CLASS_MAP to find the unarchiving delegate of a uid
     */
    classForUid(index: any): any;
    decodeKey(obj: any, key: any): any;
    decodeObject(index: any): any;
    toObject(): any;
}
/**
 * Capable of packing an object tree into the NSKeyedArchive format.
 * Apple's implementation can be found here:
 * https://github.com/apple/swift-corelibs-foundation/blob/main/Sources/Foundation/NSKeyedArchiver.swift
 */
declare class Archive {
    constructor(inputObject: any);
    input: any;
    /** @type {any[]} */
    objects: any[];
    uidForArchiver(archiver: any, ...addition: any[]): any;
    archive(obj: any): any;
    encode(val: any): any;
    encodeTopLevel(obj: any, archiveObj: any): void;
    encodeArray(objs: any, archiveObj: any): void;
    encodeSet(objs: any, archiveObj: any): void;
    encodeDict(obj: any, archiveObj: any): void;
    /**
     *
     * @param {XCTestConfiguration} obj
     * @param {*} archiveObj
     */
    encodeXCTestConfiguration(obj: XCTestConfiguration, archiveObj: any): void;
    toBytes(): Buffer;
}
export {};
//# sourceMappingURL=nskeyed.d.ts.map