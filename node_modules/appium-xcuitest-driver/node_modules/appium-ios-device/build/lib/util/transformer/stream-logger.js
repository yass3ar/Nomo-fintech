"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamLogger = void 0;
const stream_1 = __importDefault(require("stream"));
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = __importDefault(require("../../logger"));
const MIN_PRINTABLE_CHAR = 32;
const MAX_PRINTABLE_CHAR = 126;
const CHARACTERS_PER_LINE = 19;
class StreamLogger extends stream_1.default.Transform {
    constructor(direction, verbose = false) {
        super({ objectMode: true });
        this._direction = direction;
        this._verbose = verbose;
    }
    _transform(data, encoding, onData) {
        if (this._verbose) {
            try {
                this._log(data);
            }
            catch (err) {
                // in case something goes wrong, log it so we can fix the parsing
                // and also allow everything to continue without interruption
                logger_1.default.debug(`Error logging data: ${err.message}`);
            }
        }
        this.push(data);
        onData();
    }
    _log(data) {
        logger_1.default.debug(`Data ${this._direction === StreamLogger.SEND ? 'sent' : 'received'}, length: ${data.length}`);
        // format as used by ios-webkit-debug-proxy as well as tools like socat
        // print out the data in two sections, one the hexadecimal renderings of the characters,
        // the other the printable characters (with '.' for unprintable characters).
        let i = 0;
        while (i < data.length) {
            let hex = [], char = [];
            // create each line of text to output
            for (let j = 0; j < CHARACTERS_PER_LINE; j++) {
                if (i >= data.length) {
                    // fill in the charcode section with blanks, for formatting,
                    // when there is no more data
                    hex[j] = '  ';
                    continue;
                }
                const charCode = data[i++];
                // hexadecimal representation, forced into 2 places
                hex[j] = lodash_1.default.padStart(charCode.toString(16).toUpperCase(), 2, '0');
                // character representation, with '.' when unprintable
                char[j] = charCode < MIN_PRINTABLE_CHAR || charCode > MAX_PRINTABLE_CHAR
                    ? '.'
                    : String.fromCharCode(charCode);
            }
            logger_1.default.debug(`${hex.join(' ')} ${char.join('')}`);
        }
    }
}
exports.StreamLogger = StreamLogger;
StreamLogger.SEND = 0;
StreamLogger.RECEIVE = 1;
exports.default = StreamLogger;
//# sourceMappingURL=stream-logger.js.map