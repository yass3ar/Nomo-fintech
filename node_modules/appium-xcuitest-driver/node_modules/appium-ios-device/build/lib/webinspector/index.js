"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WEB_INSPECTOR_SERVICE_NAME = exports.WebInspectorService = void 0;
exports.cleanupRpcObject = cleanupRpcObject;
const webinspector_decoder_1 = __importDefault(require("./transformer/webinspector-decoder"));
const webinspector_encoder_1 = __importDefault(require("./transformer/webinspector-encoder"));
const plist_service_decoder_1 = __importDefault(require("../plist-service/transformer/plist-service-decoder"));
const plist_service_encoder_1 = __importDefault(require("../plist-service/transformer/plist-service-encoder"));
const length_based_splitter_1 = __importDefault(require("../util/transformer/length-based-splitter"));
const stream_logger_1 = __importDefault(require("../util/transformer/stream-logger"));
const lodash_1 = __importDefault(require("lodash"));
const support_1 = require("@appium/support");
const constants_1 = require("../constants");
const logger_1 = __importDefault(require("../logger"));
const base_service_1 = require("../base-service");
const WEB_INSPECTOR_SERVICE_NAME = 'com.apple.webinspector';
exports.WEB_INSPECTOR_SERVICE_NAME = WEB_INSPECTOR_SERVICE_NAME;
const MAX_FRAME_SIZE = 20 * constants_1.MB;
const PARTIAL_MESSAGE_SUPPORT_DEPRECATION_VERSION = 11;
function cleanupRpcObject(obj) {
    const isArray = lodash_1.default.isArray(obj);
    if (!lodash_1.default.isPlainObject(obj) && !isArray) {
        return obj;
    }
    if (isArray) {
        return lodash_1.default.filter(obj, lodash_1.default.negate(lodash_1.default.isNil));
    }
    return lodash_1.default.reduce(obj, (result, value, key) => {
        if (!lodash_1.default.isNil(value)) {
            result[key] = cleanupRpcObject(value);
        }
        return result;
    }, {});
}
/**
 * @typedef {Object} WebInspectorServiceOptions
 *
 * @property {number} majorOsVersion The major version of the os version
 * @property {boolean} isSimulator Whether the device is a simulator
 * @property {number?} socketChunkSize Size, in bytes of the chunks to send to
 *                                     real device (only iOS 11+). Defaults to
 *                                     16384 bytes (the TLSSocket max).
 * @property {boolean} verbose Turn on logging of each message sent or received.
 *                             Defaults to false
 * @property {boolean} verboseHexDump Turn on logging of _all_ communication as
 *                                    hex dump. Defaults to false
 * @property {*} socketClient The socket client where the communication will happen
 * @property {number} maxFrameLength [20 * 1024 * 1024] - The maximum size
 *                                   in bytes of a single data frame
 *                                   in the device communication protocol
 */
class WebInspectorService extends base_service_1.BaseServiceSocket {
    /**
     * The main service for communication with the webinspectord
     *
     * @param {Partial<WebInspectorServiceOptions>} opts
     */
    constructor(opts = {}) {
        const { majorOsVersion, isSimulator = false, socketChunkSize, verbose = false, verboseHexDump = false, socketClient, maxFrameLength = MAX_FRAME_SIZE, } = opts;
        super(socketClient);
        // set the largest fragment size for the socket, if the option is there
        if (lodash_1.default.isFunction(socketClient.setMaxSendFragment) && !lodash_1.default.isNil(socketChunkSize) && socketChunkSize > 0) {
            if (socketClient.setMaxSendFragment(socketChunkSize)) {
                logger_1.default.debug(`Maximum TLS fragment size set to '${socketChunkSize}'`);
            }
            else {
                // anything over the _actual_ maximum will fail, and things will remain the same
                logger_1.default.warn(`Unable to set TLS fragment size to '${socketChunkSize}'`);
            }
        }
        this._verbose = verbose;
        this._isSimulator = isSimulator;
        this._majorOsVersion = majorOsVersion;
        if (!isSimulator && !lodash_1.default.isNil(majorOsVersion) && majorOsVersion < PARTIAL_MESSAGE_SUPPORT_DEPRECATION_VERSION) {
            this._initializePartialMessageSupport(verboseHexDump, maxFrameLength);
        }
        else {
            this._initializeFullMessageSupport(verboseHexDump, maxFrameLength);
        }
    }
    /**
     * Intializes the data flow for iOS 11+.
     *
     * @param {boolean} verbose - whether to print out the hex dump for communication
     * @param {number} maxFrameLength - The maximum size in bytes of a single data frame
     *                                  in the device communication protocol
     */
    _initializeFullMessageSupport(verbose, maxFrameLength) {
        this._decoder = new plist_service_decoder_1.default();
        this._socketClient
            // log first, in case there is a problem in processing
            .pipe(new stream_logger_1.default(stream_logger_1.default.RECEIVE, verbose))
            .pipe(this._splitter = new length_based_splitter_1.default({
            readableStream: this._socketClient,
            littleEndian: false,
            maxFrameLength,
            lengthFieldOffset: 0,
            lengthFieldLength: 4,
            lengthAdjustment: 4,
        }))
            .pipe(this._decoder);
        this._encoder = new plist_service_encoder_1.default();
        this._encoder
            .pipe(new stream_logger_1.default(stream_logger_1.default.SEND, verbose))
            .pipe(this._socketClient);
    }
    /**
     * Intializes the data flow for iOS < 11, where data is separated into partial
     * messages before sending.
     *
     * @param {boolean} verbose - whether to print out the hex dump for communication
     * @param {number} maxFrameLength - The maximum size in bytes of a single data frame
     *                                  in the device communication protocol
     */
    _initializePartialMessageSupport(verbose, maxFrameLength) {
        // 1MB as buffer for bulding webinspector full messages. We can increase the value if more buffer is needed
        this._decoder = new webinspector_decoder_1.default(constants_1.MB);
        this._socketClient
            // log first, in case there is a problem in processing
            .pipe(new stream_logger_1.default(stream_logger_1.default.RECEIVE, verbose))
            .pipe(this._splitter = new length_based_splitter_1.default({
            readableStream: this._socketClient,
            littleEndian: false,
            maxFrameLength,
            lengthFieldOffset: 0,
            lengthFieldLength: 4,
            lengthAdjustment: 4,
        }))
            .pipe(new plist_service_decoder_1.default())
            .pipe(this._decoder);
        this._encoder = new webinspector_encoder_1.default();
        this._encoder
            .pipe(new plist_service_encoder_1.default())
            .pipe(new stream_logger_1.default(stream_logger_1.default.SEND, verbose))
            .pipe(this._socketClient);
    }
    /**
     * Sends an object to the webinspectord socket
     * @param {Object} rpcObject The object that will be sent
     * @throws Will throw an error when the object is null or undefined
     */
    sendMessage(rpcObject) {
        if (lodash_1.default.isNil(rpcObject)) {
            throw new Error('Cannot send a null object');
        }
        let message = rpcObject;
        let lastError;
        try {
            try {
                // @ts-ignore _encoder must be present
                this._encoder.write(message);
            }
            catch (e) {
                // Workaround for https://github.com/joeferner/node-bplist-creator/issues/29
                if (e instanceof TypeError) {
                    message = cleanupRpcObject(message);
                    // @ts-ignore _encoder must be present
                    this._encoder.write(message);
                }
                else {
                    throw e;
                }
            }
        }
        catch (err) {
            lastError = err;
        }
        if (this._verbose || lastError) {
            logger_1.default.debug('Sent message to Web Inspector:');
            logger_1.default.debug(support_1.util.jsonStringify(message, null));
            if (!lodash_1.default.isEqual(message, rpcObject)) {
                logger_1.default.debug('Original message:');
                logger_1.default.debug(support_1.util.jsonStringify(rpcObject, null));
            }
        }
        if (lastError) {
            throw lastError;
        }
        // write an empty message, which on real devices ensures the actual message
        // gets sent to the device. without this it will periodically hang with
        // nothing sent
        // however, this causes webinspectord to crash on devices running iOS 10
        // @ts-ignore _majorOsVersion could be present
        if (!this._isSimulator && this._majorOsVersion >= PARTIAL_MESSAGE_SUPPORT_DEPRECATION_VERSION) {
            // @ts-ignore _encoder must be present
            this._encoder.write(' ');
        }
    }
    /** The callback function which will be called during message listening
     * @callback MessageCallback
     * @param {Object} object The rpc object that is sent from the webinspectord
     */
    /**
     * Listen to messages coming from webinspectord
     * @param {MessageCallback} onData
     */
    listenMessage(onData) {
        // @ts-ignore _decoder must be present
        this._decoder.on('data', (data) => {
            if (this._verbose) {
                logger_1.default.debug('Received message from Web Inspector:');
                logger_1.default.debug(support_1.util.jsonStringify(data, null));
            }
            onData(data);
        });
    }
}
exports.WebInspectorService = WebInspectorService;
exports.default = WebInspectorService;
//# sourceMappingURL=index.js.map