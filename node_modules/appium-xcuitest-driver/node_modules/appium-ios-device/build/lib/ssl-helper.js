"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeToSSL = upgradeToSSL;
exports.enableSSLHandshakeOnly = enableSSLHandshakeOnly;
const tls_1 = __importDefault(require("tls"));
const net_1 = __importDefault(require("net"));
const bluebird_1 = __importDefault(require("bluebird"));
const HANDSHAKE_TIMEOUT_MS = 10000;
function upgradeToSSL(socket, key, cert) {
    return new tls_1.default.TLSSocket(socket, {
        rejectUnauthorized: false,
        secureContext: tls_1.default.createSecureContext({
            key,
            cert
        })
    });
}
/**
 * After the ssl protocol is successfully handshake, close the ssl protocol channel and use text transmission
 * @param socket
 * @param key
 * @param cert
 * @returns {Promise<NodeJS.Socket>} Duplicate the input socket
 */
async function enableSSLHandshakeOnly(socket, key, cert) {
    const sslSocket = tls_1.default.connect({
        socket,
        secureContext: tls_1.default.createSecureContext({
            key,
            cert
        }),
        rejectUnauthorized: false,
    });
    // stop receiving data after successful handshake
    await new bluebird_1.default((resolve, reject) => {
        const timeoutHandler = setTimeout(() => {
            if (!sslSocket.destroyed) {
                sslSocket.end();
            }
            return reject(new Error('ssl handshake error'));
        }, HANDSHAKE_TIMEOUT_MS);
        sslSocket.once('secureConnect', () => {
            clearTimeout(timeoutHandler);
            // @ts-ignore This is a hack
            sslSocket._handle.readStop();
            return resolve();
        });
    });
    // Duplicate the socket. Return a new socket object connected to the same system resource
    return new net_1.default.Socket({ fd: socket._handle.fd });
}
//# sourceMappingURL=ssl-helper.js.map