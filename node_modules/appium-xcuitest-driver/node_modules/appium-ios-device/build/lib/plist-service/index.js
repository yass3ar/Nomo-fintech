"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlistService = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const ssl_helper_1 = require("../ssl-helper");
const plist_service_encoder_1 = __importDefault(require("./transformer/plist-service-encoder"));
const plist_service_decoder_1 = __importDefault(require("./transformer/plist-service-decoder"));
const length_based_splitter_1 = __importDefault(require("../util/transformer/length-based-splitter"));
const base_service_1 = require("../base-service");
const constants_1 = require("../constants");
const MAX_FRAME_SIZE = 1 * constants_1.MB;
const CHECK_FREQ_MS = 50;
class PlistService extends base_service_1.BaseServiceSocket {
    constructor(socketClient) {
        super(socketClient);
        this._decoder = new plist_service_decoder_1.default();
        this._splitter = new length_based_splitter_1.default({
            readableStream: socketClient,
            littleEndian: false,
            maxFrameLength: MAX_FRAME_SIZE,
            lengthFieldOffset: 0,
            lengthFieldLength: 4,
            lengthAdjustment: 4,
        });
        this._socketClient.pipe(this._splitter).pipe(this._decoder);
        this._encoder = new plist_service_encoder_1.default();
        this._encoder.pipe(this._socketClient);
        this._assignClientFailureHandlers(this._encoder);
        this.replyQueue = [];
        this._decoder.on('data', (data) => this.replyQueue.push(data));
    }
    async sendPlistAndReceive(json, timeout = 5000) {
        this.sendPlist(json);
        return await this.receivePlist(timeout);
    }
    sendPlist(json) {
        if (!json) {
            throw new Error('Cant send a null a object');
        }
        this._encoder.write(json);
    }
    async receivePlist(timeout = 5000) {
        return await new bluebird_1.default((resolve, reject) => {
            const queue = this.replyQueue;
            const data = queue.shift();
            if (data) {
                resolve(data);
                return;
            }
            const checkExist = setInterval(() => {
                const data = queue.shift();
                if (!data) {
                    return;
                }
                clearInterval(checkExist);
                resolve(data);
            }, CHECK_FREQ_MS);
            setTimeout(() => {
                clearInterval(checkExist);
                reject(new Error(`Failed to receive any data within the timeout: ${timeout}`));
            }, timeout);
        });
    }
    enableSessionSSL(hostPrivateKey, hostCertificate) {
        this._socketClient.unpipe(this._splitter);
        this._encoder.unpipe(this._socketClient);
        this._socketClient = (0, ssl_helper_1.upgradeToSSL)(this._socketClient, hostPrivateKey, hostCertificate);
        this._encoder.pipe(this._socketClient);
        this._socketClient.pipe(this._splitter).pipe(this._decoder);
    }
}
exports.PlistService = PlistService;
exports.default = PlistService;
//# sourceMappingURL=index.js.map