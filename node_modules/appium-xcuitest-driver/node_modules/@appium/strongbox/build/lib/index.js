"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseItem = exports.strongbox = exports.Strongbox = exports.DEFAULT_SUFFIX = void 0;
const env_paths_1 = __importDefault(require("env-paths"));
const promises_1 = require("node:fs/promises");
const node_path_1 = __importDefault(require("node:path"));
const base_item_1 = require("./base-item");
Object.defineProperty(exports, "BaseItem", { enumerable: true, get: function () { return base_item_1.BaseItem; } });
const util_1 = require("./util");
/**
 * Set of known `Item` encodings
 * @internal
 */
const ITEM_ENCODINGS = new Set([
    'ascii',
    'utf8',
    'utf-8',
    'utf16le',
    'ucs2',
    'ucs-2',
    'base64',
    'base64url',
    'latin1',
    'binary',
    'hex',
    null,
]);
/**
 * Type guard for encodings
 * @param value any
 * @returns `true` is `value` is a valid file encoding
 */
function isEncoding(value) {
    return ITEM_ENCODINGS.has(value);
}
/**
 * Default container suffix if no explicit container is provided.
 *
 * @see {@linkcode StrongboxOpts}
 */
exports.DEFAULT_SUFFIX = 'strongbox';
/**
 * Main entry point for use of this module
 *
 * Manages multiple {@linkcode Item}s.
 */
class Strongbox {
    /**
     * Slugifies the name & determines the directory
     * @param name Name of instance
     * @param opts Options
     */
    constructor(name, opts = {}) {
        this.name = name;
        this.id = (0, util_1.slugify)(name);
        let newOpts = this.setDefaultOptions(opts);
        newOpts = this.checkOptions(newOpts);
        this.defaultItemCtor = newOpts.defaultItemCtor;
        this.container = newOpts.container;
        this.suffix = newOpts.suffix;
        this.items = new Map();
    }
    /**
     * Creates a new {@linkcode Strongbox}
     * @param name Name of instance
     * @param opts Options
     * @returns New instance
     */
    static create(name, opts) {
        return new Strongbox(name, opts);
    }
    /**
     * Clears _all_ items.
     *
     * @param force - If `true`, will rimraf the container. Otherwise, will only delete individual items.
     */
    async clearAll(force = false) {
        const items = [...this.items.values()].map((ref) => ref.deref()).filter(Boolean);
        await Promise.all(items.map((item) => item.clear()));
        if (force) {
            await (0, promises_1.rm)(this.container, { recursive: true });
        }
    }
    async createItem(name, encodingOrCtor, encoding) {
        if (isEncoding(encodingOrCtor)) {
            encoding = encodingOrCtor;
            encodingOrCtor = this.defaultItemCtor;
        }
        const item = new (encodingOrCtor ?? this.defaultItemCtor)(name, this, encoding);
        if (this.items.has(item.id)) {
            throw new ReferenceError(`Item with id "${item.id}" already exists`);
        }
        try {
            await item.read();
        }
        catch (e) {
            if (e.code !== 'ENOENT') {
                throw e;
            }
        }
        this.items.set(item.id, new WeakRef(item));
        return item;
    }
    async createItemWithValue(name, value, encodingOrCtor, encoding) {
        const item = isEncoding(encodingOrCtor)
            ? await this.createItem(name, encodingOrCtor)
            : await this.createItem(name, encodingOrCtor, encoding);
        await item.write(value);
        return item;
    }
    /**
     * Attempts to retrieve an {@linkcode Item} by its `id`.
     * @param id ID of item
     * @returns An `Item`, if found
     */
    getItem(id) {
        const ref = this.items.get(id);
        return ref?.deref();
    }
    /**
     * Performs runtime validation (and optionally transformation) of options.
     *
     * Should not set defaults.
     *
     * The default implementation slugifies any custom container name and suffix.
     *
     * Subclasses should override this method to perform additional validation as needed.
     * @param opts - Options
     */
    checkOptions(opts) {
        opts.suffix = (0, util_1.slugify)(opts.suffix);
        if (opts.container) {
            opts.container = opts.container.split(node_path_1.default.sep).map(util_1.slugify).join(node_path_1.default.sep);
            if (!node_path_1.default.isAbsolute(opts.container)) {
                throw new TypeError(`container slug ${opts.container} must be an absolute path`);
            }
        }
        else {
            opts.container = node_path_1.default.join((0, env_paths_1.default)(this.id).data, opts.suffix);
        }
        return opts;
    }
    /**
     * Sets defaults for options.
     *
     * Subclasses should override as necessary.
     * @param opts Options
     * @returns Options with defaults applied
     */
    setDefaultOptions(opts = {}) {
        const newOpts = opts;
        newOpts.suffix = opts.suffix ?? exports.DEFAULT_SUFFIX;
        newOpts.defaultItemCtor = opts.defaultItemCtor ?? base_item_1.BaseItem;
        return newOpts;
    }
}
exports.Strongbox = Strongbox;
/**
 * {@inheritdoc Strongbox.create}
 */
exports.strongbox = Strongbox.create;
//# sourceMappingURL=index.js.map