"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Simctl = void 0;
const lodash_1 = __importDefault(require("lodash"));
const which_1 = __importDefault(require("which"));
const logger_1 = __importStar(require("./logger"));
const helpers_1 = require("./helpers");
const teen_process_1 = require("teen_process");
const addmedia_1 = __importDefault(require("./subcommands/addmedia"));
const appinfo_1 = __importDefault(require("./subcommands/appinfo"));
const boot_1 = __importDefault(require("./subcommands/boot"));
const bootstatus_1 = __importDefault(require("./subcommands/bootstatus"));
const create_1 = __importDefault(require("./subcommands/create"));
const delete_1 = __importDefault(require("./subcommands/delete"));
const erase_1 = __importDefault(require("./subcommands/erase"));
const get_app_container_1 = __importDefault(require("./subcommands/get_app_container"));
const install_1 = __importDefault(require("./subcommands/install"));
const io_1 = __importDefault(require("./subcommands/io"));
const keychain_1 = __importDefault(require("./subcommands/keychain"));
const launch_1 = __importDefault(require("./subcommands/launch"));
const list_1 = __importDefault(require("./subcommands/list"));
const openurl_1 = __importDefault(require("./subcommands/openurl"));
const pbcopy_1 = __importDefault(require("./subcommands/pbcopy"));
const pbpaste_1 = __importDefault(require("./subcommands/pbpaste"));
const privacy_1 = __importDefault(require("./subcommands/privacy"));
const push_1 = __importDefault(require("./subcommands/push"));
const getenv_1 = __importDefault(require("./subcommands/getenv"));
const shutdown_1 = __importDefault(require("./subcommands/shutdown"));
const spawn_1 = __importDefault(require("./subcommands/spawn"));
const terminate_1 = __importDefault(require("./subcommands/terminate"));
const ui_1 = __importDefault(require("./subcommands/ui"));
const uninstall_1 = __importDefault(require("./subcommands/uninstall"));
const location_1 = __importDefault(require("./subcommands/location"));
const SIMCTL_ENV_PREFIX = 'SIMCTL_CHILD_';
const DEFAULT_OPTS = {
    xcrun: {
        path: null,
    },
    execTimeout: helpers_1.DEFAULT_EXEC_TIMEOUT,
    logErrors: true,
};
/**
 * @typedef {Object} XCRun
 * @property {string?} path Full path to the xcrun script
 */
/**
 * @typedef {{asynchronous: true}} TAsyncOpts
 */
/**
 * @typedef {Object} ExecOpts
 * @property {string[]} [args=[]] - The list of additional subcommand arguments.
 * It's empty by default.
 * @property {Record<string, any>} [env={}] - Environment variables mapping. All these variables
 * will be passed Simulator and used in the executing function.
 * @property {boolean} [logErrors=true] - Set it to _false_ to throw execution errors
 * immediately without logging any additional information.
 * @property {boolean} [asynchronous=false] - Whether to execute the given command
 * 'synchronously' or 'asynchronously'. Affects the returned result of the function.
 * @property {string} [encoding] - Explicitly sets streams encoding for the executed
 * command input and outputs.
 * @property {string|string[]} [architectures] - One or more architecture names to be enforced while
 * executing xcrun. See https://github.com/appium/appium/issues/18966 for more details.
 * @property {number} [timeout] - The maximum number of milliseconds
 * to wait for single synchronous xcrun command. If not provided explicitly, then
 * the value of execTimeout property is used by default.
 */
/**
 * @typedef {Object} SimctlOpts
 * @property {XCRun} [xcrun] - The xcrun properties. Currently only one property
 * is supported, which is `path` and it by default contains `null`, which enforces
 * the instance to automatically detect the full path to `xcrun` tool and to throw
 * an exception if it cannot be detected. If the path is set upon instance creation
 * then it is going to be used by `exec` and no autodetection will happen.
 * @property {number} [execTimeout=600000] - The default maximum number of milliseconds
 * to wait for single synchronous xcrun command.
 * @property {boolean} [logErrors=true] - Whether to wire xcrun error messages
 * into debug log before throwing them.
 * @property {string?} [udid] - The unique identifier of the current device, which is
 * going to be implicitly passed to all methods, which require it. It can either be set
 * upon instance creation if it is already known in advance or later when/if needed via the
 * corresponding instance setter.
 * @property {string?} [devicesSetPath] - Full path to the set of devices that you want to manage.
 * By default this path usually equals to ~/Library/Developer/CoreSimulator/Devices
 */
class Simctl {
    /**
     * @param {SimctlOpts} [opts={}]
     */
    constructor(opts = {}) {
        this.addMedia = addmedia_1.default.addMedia;
        this.appInfo = appinfo_1.default.appInfo;
        this.bootDevice = boot_1.default.bootDevice;
        this.startBootMonitor = bootstatus_1.default.startBootMonitor;
        this.createDevice = create_1.default.createDevice;
        this.deleteDevice = delete_1.default.deleteDevice;
        this.eraseDevice = erase_1.default.eraseDevice;
        this.getAppContainer = get_app_container_1.default.getAppContainer;
        this.getEnv = getenv_1.default.getEnv;
        this.installApp = install_1.default.installApp;
        this.getScreenshot = io_1.default.getScreenshot;
        this.addRootCertificate = keychain_1.default.addRootCertificate;
        this.addCertificate = keychain_1.default.addCertificate;
        this.resetKeychain = keychain_1.default.resetKeychain;
        this.launchApp = launch_1.default.launchApp;
        this.getDevicesByParsing = list_1.default.getDevicesByParsing;
        this.getDevices = list_1.default.getDevices;
        this.getRuntimeForPlatformVersionViaJson = list_1.default.getRuntimeForPlatformVersionViaJson;
        this.getRuntimeForPlatformVersion = list_1.default.getRuntimeForPlatformVersion;
        this.getDeviceTypes = list_1.default.getDeviceTypes;
        this.list = list_1.default.list;
        this.setLocation = location_1.default.setLocation;
        this.clearLocation = location_1.default.clearLocation;
        this.openUrl = openurl_1.default.openUrl;
        this.setPasteboard = pbcopy_1.default.setPasteboard;
        this.getPasteboard = pbpaste_1.default.getPasteboard;
        this.grantPermission = privacy_1.default.grantPermission;
        this.revokePermission = privacy_1.default.revokePermission;
        this.resetPermission = privacy_1.default.resetPermission;
        this.pushNotification = push_1.default.pushNotification;
        this.shutdownDevice = shutdown_1.default.shutdownDevice;
        this.spawnProcess = spawn_1.default.spawnProcess;
        this.spawnSubProcess = spawn_1.default.spawnSubProcess;
        this.terminateApp = terminate_1.default.terminateApp;
        this.getAppearance = ui_1.default.getAppearance;
        this.setAppearance = ui_1.default.setAppearance;
        this.removeApp = uninstall_1.default.removeApp;
        opts = lodash_1.default.cloneDeep(opts);
        lodash_1.default.defaultsDeep(opts, DEFAULT_OPTS);
        for (const key of lodash_1.default.keys(DEFAULT_OPTS)) {
            this[key] = opts[key];
        }
        /** @type {string?} */
        this._udid = lodash_1.default.isNil(opts.udid) ? null : opts.udid;
        /** @type {string?} */
        this._devicesSetPath = lodash_1.default.isNil(opts.devicesSetPath) ? null : opts.devicesSetPath;
    }
    set udid(value) {
        this._udid = value;
    }
    get udid() {
        return this._udid;
    }
    set devicesSetPath(value) {
        this._devicesSetPath = value;
    }
    get devicesSetPath() {
        return this._devicesSetPath;
    }
    /**
     * @param {string?} [commandName=null]
     * @returns {string}
     */
    requireUdid(commandName = null) {
        if (!this.udid) {
            throw new Error(`udid is required to be set for ` +
                (commandName ? `the '${commandName}' command` : 'this simctl command'));
        }
        return this.udid;
    }
    /**
     * @returns {Promise<string>}
     */
    async requireXcrun() {
        const xcrunBinary = (0, helpers_1.getXcrunBinary)();
        if (!this.xcrun.path) {
            try {
                this.xcrun.path = await (0, which_1.default)(xcrunBinary);
            }
            catch (e) {
                throw new Error(`${xcrunBinary} tool has not been found in PATH. ` +
                    `Are Xcode developers tools installed?`);
            }
        }
        return this.xcrun.path;
    }
    /**
     * Execute the particular simctl command.
     *
     * @template {ExecOpts} TExecOpts
     * @param {string} subcommand - One of available simctl subcommands.
     * Execute `xcrun simctl` in Terminal to see the full list  of available subcommands.
     * @param {TExecOpts} [opts]
     * @return {Promise<TExecOpts extends TAsyncOpts ? import('teen_process').SubProcess : import('teen_process').TeenProcessExecResult>}
     * Either the result of teen process's `exec` or
     * `SubProcess` instance depending of `opts.asynchronous` value.
     * @throws {Error} If the simctl subcommand command returns non-zero return code.
     */
    async exec(subcommand, opts) {
        let { args = [], env = {}, asynchronous = false, encoding, logErrors = true, architectures, timeout, } = opts ?? {};
        // run a particular simctl command
        args = [
            'simctl',
            ...(this.devicesSetPath ? ['--set', this.devicesSetPath] : []),
            subcommand,
            ...args
        ];
        // Prefix all passed in environment variables with 'SIMCTL_CHILD_', simctl
        // will then pass these to the child (spawned) process.
        env = lodash_1.default.defaults(lodash_1.default.mapKeys(env, (value, key) => lodash_1.default.startsWith(key, SIMCTL_ENV_PREFIX) ? key : `${SIMCTL_ENV_PREFIX}${key}`), process.env);
        const execOpts = {
            env,
            encoding,
        };
        if (!asynchronous) {
            execOpts.timeout = timeout || this.execTimeout;
        }
        const xcrun = await this.requireXcrun();
        try {
            let execArgs = [xcrun, args, execOpts];
            if (architectures?.length) {
                const archArgs = lodash_1.default.flatMap((lodash_1.default.isArray(architectures) ? architectures : [architectures]).map((arch) => ['-arch', arch]));
                execArgs = ['arch', [...archArgs, xcrun, ...args], execOpts];
            }
            // @ts-ignore We know what we are doing here
            return asynchronous ? new teen_process_1.SubProcess(...execArgs) : await (0, teen_process_1.exec)(...execArgs);
        }
        catch (e) {
            if (!this.logErrors || !logErrors) {
                // if we don't want to see the errors, just throw and allow the calling
                // code do what it wants
            }
            else if (e.stderr) {
                const msg = `Error running '${subcommand}': ${e.stderr.trim()}`;
                logger_1.default.debug(logger_1.LOG_PREFIX, msg);
                e.message = msg;
            }
            else {
                logger_1.default.debug(logger_1.LOG_PREFIX, e.message);
            }
            throw e;
        }
    }
}
exports.Simctl = Simctl;
exports.default = Simctl;
//# sourceMappingURL=simctl.js.map